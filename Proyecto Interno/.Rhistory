filter(!is.na(contribucion_pc1)) %>%
group_by(subclase) %>%
mutate(
l_i = sqrt(contribucion_pc1 / 100),
mean_l = mean(l_i),
s_i = l_i / mean_l
) %>%
ungroup() %>%
select(subclase, articulo, s_i)
pca_contrib = readxl::read_excel("margen-dist\\pca\\resultados_pca.xlsx",
sheet = 2) %>% janitor::clean_names()
pca_contrib$articulo = pca_contrib$producto
s_i_data <- pca_contrib %>%
filter(!is.na(contribucion_pc1)) %>%
group_by(subclase) %>%
mutate(
l_i = sqrt(contribucion_pc1 / 100),
mean_l = mean(l_i),
s_i = l_i / mean_l
) %>%
ungroup() %>%
select(subclase, articulo, s_i)
s_i_data
# Recuperar contribuciones del IPC
pca_contrib.x = s_i_data %>% filter(articulo == unique(ipc_df$articulo)[!is.na(unique(ipc_df$articulo))])
alpha = unique(pca_contrib.x$s_i, na.rm = TRUE)[1]
alpha
alpha[is.na(alpha)] = 1
# Recuperar contribuciones del IPC
pca_contrib.x = s_i_data %>% filter(articulo == unique(ipc_df$articulo)[!is.na(unique(ipc_df$articulo))])
alpha = unique(pca_contrib.x$s_i, na.rm = TRUE)[1]
alpha[is.na(alpha)] = 1
if((length(pca_contrib.x$contribucion_pc1) != 0) & (!round(alpha, 0) %in% c(0.5, 1))){
ipc_df = ipc_df %>% left_join(pca_contrib.x, by = "articulo")
ipc_df$contribucion_pc1 = max(ipc_df$contribucion_pc1, na.rm = TRUE)
} else {
ipc_df$contribucion_pc1 = 1
}
if((length(pca_contrib.x$s_i) != 0) & (!round(alpha, 0) %in% c(0.5, 1))){
ipc_df = ipc_df %>% left_join(pca_contrib.x, by = "articulo")
ipc_df$s_i = max(ipc_df$s_i, na.rm = TRUE)
} else {
ipc_df$s_i = 1
}
# Merge
ipc_df = test.df %>% full_join(df_ipc, by = c("ano", "mes_num")) %>%
select(fecha, ano, mes_num, ciudad, nombre_ciudad,
cod_subclase,
codigo_articulo, articulo, precio_500g,ipc)%>%
arrange(fecha) %>%
mutate(precio_hat = NA)
# Recuperar contribuciones del IPC
pca_contrib.x = s_i_data %>% filter(articulo == unique(ipc_df$articulo)[!is.na(unique(ipc_df$articulo))])
alpha = unique(pca_contrib.x$s_i, na.rm = TRUE)[1]
alpha[is.na(alpha)] = 1
if((length(pca_contrib.x$s_i) != 0) & (!round(alpha, 0) %in% c(0.5, 1))){
ipc_df = ipc_df %>% left_join(pca_contrib.x, by = "articulo")
ipc_df$s_i = max(ipc_df$s_i, na.rm = TRUE)
} else {
ipc_df$s_i = 1
}
# Llenar precios hacia adelante usando la variación del IPC
ipc_df$precio_hat[ipc_df$fecha == "2015-01-01" &
!is.na(ipc_df$fecha)] = ipc_df$precio_500g[ipc_df$fecha == "2015-01-01" &
!is.na(ipc_df$fecha)]
ipc_df$s_i
for (k in 2:nrow(ipc_df)) {
if (is.na(ipc_df$precio_hat[k])) {
ipc_df$precio_hat[k] = (ipc_df$precio_hat[k - 1] * (ipc_df$ipc[k] / ipc_df$ipc[k - 1]))^ipc_df$s_i
}
}
# Unir con la base de datos
test.df2 = test.df %>% left_join(ipc_df[c("fecha", "ipc",
"precio_hat")],
by = "fecha") %>%
select(fecha, nombre_ciudad, articulo, precio_500g,
precio_hat)
# Unir con la base de datos de entrenamiento
test.df2 = bind_rows(train.df, test.df2)
# Cálculo de la métrica sobre el conjunto de validación
valid_df <- test.df2 %>% filter(!is.na(precio_hat))
# RMSE
rmse <- sqrt(mean((valid_df$precio_500g - valid_df$precio_hat)^2))
# MAPE
mape <- mean(abs(valid_df$precio_500g - valid_df$precio_hat) / valid_df$precio_500g) * 100
resultados_metricas <- resultados_metricas %>%
add_row(
ciudad = unique(valid_df$nombre_ciudad),
articulo = unique(valid_df$articulo),
rmse = rmse,
mape = mape
)
# Validar la estimación:
plot_aux = test.df2 %>%
ggplot(aes(x = fecha)) +
geom_line(aes(y = precio_500g, color = "Precio real"), size = 1) +
geom_line(aes(y = precio_hat, color = "Precio estimado"), linetype = "dashed", size = 1) +
labs(
title = "Comparación entre precio real y estimado",
subtitle = paste0(
unique(valid_df$nombre_ciudad), " - ", unique(valid_df$articulo),
"\nRMSE = ", round(rmse, 2),
" | MAPE = ", round(mape, 2), "%"
),
x = "Fecha",
y = "Precio (500g)",
color = " "
) +
scale_color_manual(values = c("Precio real" = "black", "Precio estimado" = "red")) +
theme_bw() +
theme(
legend.position = "bottom",
plot.title = element_text(face = "bold")
)
print(plot_aux)
# Recuperar contribuciones del IPC
pca_contrib.x = s_i_data %>% filter(articulo == unique(ipc_df$articulo)[!is.na(unique(ipc_df$articulo))])
pca_contrib.x
alpha = unique(pca_contrib.x$s_i, na.rm = TRUE)[1]
alpha[is.na(alpha)] = 1
alpha
if((length(pca_contrib.x$s_i) != 0) & (!round(alpha, 0) %in% c(0.5, 1))){
ipc_df = ipc_df %>% left_join(pca_contrib.x, by = "articulo")
ipc_df$s_i = max(ipc_df$s_i, na.rm = TRUE)
} else {
ipc_df$s_i = 1
}
ipc_df$s_i
round(alpha, 0)
if((length(pca_contrib.x$s_i) != 0) & (!round(alpha, 0) %in% c(0.5))){
ipc_df = ipc_df %>% left_join(pca_contrib.x, by = "articulo")
ipc_df$s_i = max(ipc_df$s_i, na.rm = TRUE)
} else {
ipc_df$s_i = 1
}
# Merge
ipc_df = test.df %>% full_join(df_ipc, by = c("ano", "mes_num")) %>%
select(fecha, ano, mes_num, ciudad, nombre_ciudad,
cod_subclase,
codigo_articulo, articulo, precio_500g,ipc)%>%
arrange(fecha) %>%
mutate(precio_hat = NA)
# Recuperar contribuciones del IPC
pca_contrib.x = s_i_data %>% filter(articulo == unique(ipc_df$articulo)[!is.na(unique(ipc_df$articulo))])
alpha = unique(pca_contrib.x$s_i, na.rm = TRUE)[1]
alpha[is.na(alpha)] = 1
if((length(pca_contrib.x$s_i) != 0) & (!round(alpha, 0) %in% c(0.5))){
ipc_df = ipc_df %>% left_join(pca_contrib.x, by = "articulo")
ipc_df$s_i = max(ipc_df$s_i, na.rm = TRUE)
} else {
ipc_df$s_i = 1
}
# Llenar precios hacia adelante usando la variación del IPC
ipc_df$precio_hat[ipc_df$fecha == "2015-01-01" &
!is.na(ipc_df$fecha)] = ipc_df$precio_500g[ipc_df$fecha == "2015-01-01" &
!is.na(ipc_df$fecha)]
for (k in 2:nrow(ipc_df)) {
if (is.na(ipc_df$precio_hat[k])) {
ipc_df$precio_hat[k] = (ipc_df$precio_hat[k - 1] * (ipc_df$ipc[k] / ipc_df$ipc[k - 1]))^ipc_df$s_i
}
}
# Unir con la base de datos
test.df2 = test.df %>% left_join(ipc_df[c("fecha", "ipc",
"precio_hat")],
by = "fecha") %>%
select(fecha, nombre_ciudad, articulo, precio_500g,
precio_hat)
# Unir con la base de datos de entrenamiento
test.df2 = bind_rows(train.df, test.df2)
# Cálculo de la métrica sobre el conjunto de validación
valid_df <- test.df2 %>% filter(!is.na(precio_hat))
# RMSE
rmse <- sqrt(mean((valid_df$precio_500g - valid_df$precio_hat)^2))
# MAPE
mape <- mean(abs(valid_df$precio_500g - valid_df$precio_hat) / valid_df$precio_500g) * 100
resultados_metricas <- resultados_metricas %>%
add_row(
ciudad = unique(valid_df$nombre_ciudad),
articulo = unique(valid_df$articulo),
rmse = rmse,
mape = mape
)
# Validar la estimación:
plot_aux = test.df2 %>%
ggplot(aes(x = fecha)) +
geom_line(aes(y = precio_500g, color = "Precio real"), size = 1) +
geom_line(aes(y = precio_hat, color = "Precio estimado"), linetype = "dashed", size = 1) +
labs(
title = "Comparación entre precio real y estimado",
subtitle = paste0(
unique(valid_df$nombre_ciudad), " - ", unique(valid_df$articulo),
"\nRMSE = ", round(rmse, 2),
" | MAPE = ", round(mape, 2), "%"
),
x = "Fecha",
y = "Precio (500g)",
color = " "
) +
scale_color_manual(values = c("Precio real" = "black", "Precio estimado" = "red")) +
theme_bw() +
theme(
legend.position = "bottom",
plot.title = element_text(face = "bold")
)
print(plot_aux)
ipc_df$s_i
for (k in 2:nrow(ipc_df)) {
if (is.na(ipc_df$precio_hat[k])) {
ipc_df$precio_hat[k] = (ipc_df$precio_hat[k - 1] * (ipc_df$ipc[k] / ipc_df$ipc[k - 1])^ipc_df$s_i)
}
}
# Unir con la base de datos
test.df2 = test.df %>% left_join(ipc_df[c("fecha", "ipc",
"precio_hat")],
by = "fecha") %>%
select(fecha, nombre_ciudad, articulo, precio_500g,
precio_hat)
# Unir con la base de datos de entrenamiento
test.df2 = bind_rows(train.df, test.df2)
# Cálculo de la métrica sobre el conjunto de validación
valid_df <- test.df2 %>% filter(!is.na(precio_hat))
# RMSE
rmse <- sqrt(mean((valid_df$precio_500g - valid_df$precio_hat)^2))
# MAPE
mape <- mean(abs(valid_df$precio_500g - valid_df$precio_hat) / valid_df$precio_500g) * 100
resultados_metricas <- resultados_metricas %>%
add_row(
ciudad = unique(valid_df$nombre_ciudad),
articulo = unique(valid_df$articulo),
rmse = rmse,
mape = mape
)
# Validar la estimación:
plot_aux = test.df2 %>%
ggplot(aes(x = fecha)) +
geom_line(aes(y = precio_500g, color = "Precio real"), size = 1) +
geom_line(aes(y = precio_hat, color = "Precio estimado"), linetype = "dashed", size = 1) +
labs(
title = "Comparación entre precio real y estimado",
subtitle = paste0(
unique(valid_df$nombre_ciudad), " - ", unique(valid_df$articulo),
"\nRMSE = ", round(rmse, 2),
" | MAPE = ", round(mape, 2), "%"
),
x = "Fecha",
y = "Precio (500g)",
color = " "
) +
scale_color_manual(values = c("Precio real" = "black", "Precio estimado" = "red")) +
theme_bw() +
theme(
legend.position = "bottom",
plot.title = element_text(face = "bold")
)
print(plot_aux)
k = 2
ipc_df$precio_hat[k - 1]
(ipc_df$ipc[k] / ipc_df$ipc[k - 1])
(ipc_df$ipc[k] / ipc_df$ipc[k - 1])^ipc_df$s_i
(ipc_df$precio_hat[k - 1] * (ipc_df$ipc[k] / ipc_df$ipc[k - 1])^ipc_df$s_i)
(ipc_df$precio_hat[k - 1] * (ipc_df$ipc[k] / ipc_df$ipc[k - 1]))
# Merge
ipc_df = test.df %>% full_join(df_ipc, by = c("ano", "mes_num")) %>%
select(fecha, ano, mes_num, ciudad, nombre_ciudad,
cod_subclase,
codigo_articulo, articulo, precio_500g,ipc)%>%
arrange(fecha) %>%
mutate(precio_hat = NA)
# Recuperar contribuciones del IPC
pca_contrib.x = s_i_data %>% filter(articulo == unique(ipc_df$articulo)[!is.na(unique(ipc_df$articulo))])
alpha = unique(pca_contrib.x$s_i, na.rm = TRUE)[1]
alpha[is.na(alpha)] = 1
if((length(pca_contrib.x$s_i) != 0) & (!round(alpha, 0) %in% c(0.5))){
ipc_df = ipc_df %>% left_join(pca_contrib.x, by = "articulo")
ipc_df$s_i = max(ipc_df$s_i, na.rm = TRUE)
} else {
ipc_df$s_i = 1
}
# Llenar precios hacia adelante usando la variación del IPC
ipc_df$precio_hat[ipc_df$fecha == "2015-01-01" &
!is.na(ipc_df$fecha)] = ipc_df$precio_500g[ipc_df$fecha == "2015-01-01" &
!is.na(ipc_df$fecha)]
for (k in 2:nrow(ipc_df)) {
k = 2
if (is.na(ipc_df$precio_hat[k])) {
ipc_df$precio_hat[k] = (ipc_df$precio_hat[k - 1] * (ipc_df$ipc[k] / ipc_df$ipc[k - 1])^ipc_df$s_i)
}
}
for (k in 2:nrow(ipc_df)) {
if (is.na(ipc_df$precio_hat[k])) {
ipc_df$precio_hat[k] = (ipc_df$precio_hat[k - 1] * (ipc_df$ipc[k] / ipc_df$ipc[k - 1])^ipc_df$s_i)
}
}
# Unir con la base de datos
test.df2 = test.df %>% left_join(ipc_df[c("fecha", "ipc",
"precio_hat")],
by = "fecha") %>%
select(fecha, nombre_ciudad, articulo, precio_500g,
precio_hat)
# Unir con la base de datos de entrenamiento
test.df2 = bind_rows(train.df, test.df2)
# Cálculo de la métrica sobre el conjunto de validación
valid_df <- test.df2 %>% filter(!is.na(precio_hat))
# RMSE
rmse <- sqrt(mean((valid_df$precio_500g - valid_df$precio_hat)^2))
# MAPE
mape <- mean(abs(valid_df$precio_500g - valid_df$precio_hat) / valid_df$precio_500g) * 100
resultados_metricas <- resultados_metricas %>%
add_row(
ciudad = unique(valid_df$nombre_ciudad),
articulo = unique(valid_df$articulo),
rmse = rmse,
mape = mape
)
# Validar la estimación:
plot_aux = test.df2 %>%
ggplot(aes(x = fecha)) +
geom_line(aes(y = precio_500g, color = "Precio real"), size = 1) +
geom_line(aes(y = precio_hat, color = "Precio estimado"), linetype = "dashed", size = 1) +
labs(
title = "Comparación entre precio real y estimado",
subtitle = paste0(
unique(valid_df$nombre_ciudad), " - ", unique(valid_df$articulo),
"\nRMSE = ", round(rmse, 2),
" | MAPE = ", round(mape, 2), "%"
),
x = "Fecha",
y = "Precio (500g)",
color = " "
) +
scale_color_manual(values = c("Precio real" = "black", "Precio estimado" = "red")) +
theme_bw() +
theme(
legend.position = "bottom",
plot.title = element_text(face = "bold")
)
print(plot_aux)
s_i_data <- pca_contrib %>%
filter(!is.na(contribucion_pc1)) %>%
group_by(subclase) %>%
mutate(
l_i = sqrt(contribucion_pc1 / 100),
mean_l = mean(l_i),
s_i = l_i / mean_l
) %>%
ungroup() %>%
select(subclase, articulo, s_i)
View(s_i_data)
s_i_data <- pca_contrib %>%
filter(!is.na(contribucion_pc1)) %>%
group_by(subclase) %>%
mutate(
l_i = sqrt(contribucion_pc1 / 100),
mean_l = mean(l_i),
s_i = l_i / mean_l
) %>%
ungroup() %>%
select(subclase, articulo, s_i)
# Bucle
for (i in 1:length(city_i)) {
for (j in 1:length(food_j)) {
print(paste0(city_i[i], " - ", food_j[j]))
# Base de datos aux.
df.aux = dane_99_18 %>% filter(nombre_ciudad == city_i[i] &
articulo == food_j[j])
# Filtrar fechas_75
train.df = df.aux %>% dplyr::filter(fecha <= "2015-01-01")
test.df = df.aux %>% filter(fecha >= "2015-01-01")
if (length(test.df$precio_500g) == 0) {
df.aux2 = dane_99_18 %>% filter(articulo == food_j[j])
list.fail[[length(list.fail) + 1]] <- data.frame(
ciudad = city_i[i],
cod_articulo = unique(df.aux2$codigo_articulo),
cod_subclase = unique(df.aux2$cod_subclase),
articulo = food_j[j]
)
} else {
# Recuperar código en tablas correlativas
# Tabla correlativa
correlativa = readxl::read_excel("var-ipc\\correlativa_ipc.xlsx")
# Llenar por celdas combinadas
correlativa <- correlativa %>%
fill(subclase, ipc, .direction = "down") %>%
mutate(cod_subclase = paste0("0",
gasto_basico, "00"))
# Recuperar código ipc
test.df2 = test.df %>% left_join(correlativa[c("cod_subclase",
"subclase")],
by = "cod_subclase")
# Condicional (si hay más de un código que coincide, entonces
# usamos una correlativa más desagregada)
if (length(levels(as.factor(test.df2$subclase))) > 1){
corr_producto = readxl::read_excel("var-ipc\\correlativa_ipc_articulos.xlsx") %>%
mutate(codigo_articulo = cod_dane,
subclase = cod_ipc)
test.df = test.df %>% left_join(corr_producto[c("codigo_articulo",
"subclase")],
by = "codigo_articulo")
} else {
test.df = test.df2
}
# Código de subclase (formato)
test.df$subclase = paste0(test.df$subclase,"00")
#######################################
###---------------------------------###
### Variación del ÍPC: datos > 2015 ###
###---------------------------------###
#######################################
# Cargar variación del IPC
var_ipc = var_ipc_base
# Recodificar ciudades
var_ipc$ciudad[var_ipc$ciudad == "CARTAGENA DE INDIAS"] = "CARTAGENA"
var_ipc$ciudad[var_ipc$ciudad == "BOGOTÁ, D.C."] = "BOGOTÁ D.C."
# Crear variable codigo_subclase
var_ipc$cod_subclase = paste0(substr(var_ipc$subclase, 1, 8))
# Filtrar para la ciudad de interés
var_ipc = var_ipc %>% filter(ciudad == city_i[i] &
as.numeric(cod_subclase) == as.numeric(unique(test.df$subclase)))
if (length(var_ipc$numero_indice) == 0) {
list.fail[[length(list.fail) + 1]] <- data.frame(
ciudad = city_i[i],
cod_articulo = unique(df.aux$codigo_articulo),
cod_subclase = unique(df.aux$cod_subclase),
articulo = unique(df.aux$articulo)
)
} else {
# Formato long
library(tidyverse)
meses_esp <- c("Ene", "Feb", "Mar", "Abr", "May", "Jun",
"Jul", "Ago", "Sep", "Oct", "Nov", "Dic")
df_ipc <- var_ipc %>%
mutate(
mes_num = match(mes, meses_esp),
ipc = numero_indice,
ano = as.numeric(ano)
) %>%
select(ano, mes_num, ipc) %>%
arrange(ano, mes_num)
# Merge
ipc_df = test.df %>% full_join(df_ipc, by = c("ano", "mes_num")) %>%
select(fecha, ano, mes_num, ciudad, nombre_ciudad,
cod_subclase,
codigo_articulo, articulo, precio_500g,ipc)%>%
arrange(fecha) %>%
mutate(precio_hat = NA)
# Recuperar contribuciones del IPC
pca_contrib.x = s_i_data %>% filter(articulo == unique(ipc_df$articulo)[!is.na(unique(ipc_df$articulo))])
alpha = unique(pca_contrib.x$s_i, na.rm = TRUE)[1]
alpha[is.na(alpha)] = 1
if((length(pca_contrib.x$s_i) != 0) & (!round(alpha, 0) %in% c(0.5))){
ipc_df = ipc_df %>% left_join(pca_contrib.x, by = "articulo")
ipc_df$s_i = max(ipc_df$s_i, na.rm = TRUE)
} else {
ipc_df$s_i = 1
}
# Llenar precios hacia adelante usando la variación del IPC
ipc_df$precio_hat[ipc_df$fecha == "2015-01-01" &
!is.na(ipc_df$fecha)] = ipc_df$precio_500g[ipc_df$fecha == "2015-01-01" &
!is.na(ipc_df$fecha)]
for (k in 2:nrow(ipc_df)) {
if (is.na(ipc_df$precio_hat[k])) {
ipc_df$precio_hat[k] = (ipc_df$precio_hat[k - 1] * (ipc_df$ipc[k] / ipc_df$ipc[k - 1])^ipc_df$s_i)
}
}
# Unir con la base de datos
test.df2 = test.df %>% left_join(ipc_df[c("fecha", "ipc",
"precio_hat")],
by = "fecha") %>%
select(fecha, nombre_ciudad, articulo, precio_500g,
precio_hat)
# Unir con la base de datos de entrenamiento
test.df2 = bind_rows(train.df, test.df2)
# Cálculo de la métrica sobre el conjunto de validación
valid_df <- test.df2 %>% filter(!is.na(precio_hat))
# RMSE
rmse <- sqrt(mean((valid_df$precio_500g - valid_df$precio_hat)^2))
# MAPE
mape <- mean(abs(valid_df$precio_500g - valid_df$precio_hat) / valid_df$precio_500g) * 100
resultados_metricas <- resultados_metricas %>%
add_row(
ciudad = unique(valid_df$nombre_ciudad),
articulo = unique(valid_df$articulo),
rmse = rmse,
mape = mape
)
# Validar la estimación:
plot_aux = test.df2 %>%
ggplot(aes(x = fecha)) +
geom_line(aes(y = precio_500g, color = "Precio real"), size = 1) +
geom_line(aes(y = precio_hat, color = "Precio estimado"), linetype = "dashed", size = 1) +
labs(
title = "Comparación entre precio real y estimado",
subtitle = paste0(
unique(valid_df$nombre_ciudad), " - ", unique(valid_df$articulo),
"\nRMSE = ", round(rmse, 2),
" | MAPE = ", round(mape, 2), "%"
),
x = "Fecha",
y = "Precio (500g)",
color = " "
) +
scale_color_manual(values = c("Precio real" = "black", "Precio estimado" = "red")) +
theme_bw() +
theme(
legend.position = "bottom",
plot.title = element_text(face = "bold")
)
print(plot_aux)
}
}
}
}
