compute_hcost_city_date(city.x, date.x, panel),
error = function(e) {
err_log[[k_err]] <<- tibble(
ciudad = city.x,
fecha  = date.x,
error  = conditionMessage(e)
)
message("   -> ERROR HCost: ", conditionMessage(e))
k_err <<- k_err + 1
return(NULL)
}
)
if (is.null(out)) {
message("   -> NULL (sin datos suficientes / panel.aux vacío) en: ", city.x, " | ", as.character(date.x))
next
}
# Guardar raw
res_coca[[k_coca]] <- out$CoCA
res_cona[[k_cona]] <- out$CoNA
k_coca <- k_coca + 1
k_cona <- k_cona + 1
message("   -> OK: guardé CoCA y CoNA")
}
}
# Consolidar raw
coca_df <- bind_rows(res_coca)
cona_df <- bind_rows(res_cona)
saveRDS(coca_df, file.path(out_dir, "coca_raw_all.rds"))
saveRDS(cona_df, file.path(out_dir, "cona_raw_all.rds"))
# Log errores
errors_df <- bind_rows(err_log)
write.csv(errors_df, file.path(log_dir, "hcost_errors.csv"), row.names = FALSE)
message("RAW listo. CoCA rows=", nrow(coca_df), " | CoNA rows=", nrow(cona_df), " | errores=", nrow(errors_df))
# ------------------------------------------------------------
# Pasar a LONG con 3 costos (para gráficas)
# ------------------------------------------------------------
hh_size <- if (exists("HH_SIZE")) get("HH_SIZE") else NA_real_
hh_kcal <- if (exists("HH_KCAL")) get("HH_KCAL") else NA_real_
coca_long <- standardize_costs_long(coca_df, "CoCA", ciudad = NA, fecha = NA, hh_size = hh_size, hh_kcal = hh_kcal)
# OJO: arriba no sirve porque ya viene con ciudad/fecha. Mejor hacemos wrapper:
to_long_from_raw <- function(df_raw, metric_name) {
# df_raw ya tiene ciudad/fecha; preservamos y estandarizamos por “chunk” completo
# standardize_costs_long espera "df_model" SIN ciudad/fecha extra; pero soporta que existan
# entonces la llamamos directo y NO pasamos ciudad/fecha nuevos.
# Para eso, reusamos la lógica pero sin sobre-escribir ciudad/fecha.
df_model <- as_tibble(df_raw)
cost_candidates <- detect_cost_cols(df_model)
top3 <- head(cost_candidates, 3)
if (length(top3) >= 3) {
out <- df_model %>%
mutate(metric = metric_name) %>%
pivot_longer(all_of(top3), names_to = "cost_raw", values_to = "value") %>%
mutate(
cost_type = case_when(
grepl("capita|per_cap|pc", cost_raw, ignore.case = TRUE) ~ "pc_per_day",
grepl("1000\\s*kcal|1000kcal", cost_raw, ignore.case = TRUE) ~ "per_1000kcal",
TRUE ~ "hh_per_day"
)
)
return(out)
}
base_col <- if (length(cost_candidates) >= 1) cost_candidates[1] else NA_character_
if (is.na(base_col)) return(NULL)
out <- df_model %>%
mutate(
metric = metric_name,
hh_per_day = .data[[base_col]],
pc_per_day = if (!is.na(hh_size) && hh_size > 0) hh_per_day / hh_size else NA_real_,
per_1000kcal = if (!is.na(hh_kcal) && hh_kcal > 0) (hh_per_day / hh_kcal) * 1000 else NA_real_
) %>%
pivot_longer(c("hh_per_day","pc_per_day","per_1000kcal"),
names_to = "cost_type", values_to = "value")
out
}
coca_long <- to_long_from_raw(coca_df, "CoCA")
cona_long <- to_long_from_raw(cona_df, "CoNA")
metrics_long <- bind_rows(coca_long, cona_long)
saveRDS(metrics_long, file.path(out_dir, "coca_cona_long_3costs.rds"))
# ------------------------------------------------------------
# Grupo demográfico: detectar columna y crear "group"
# ------------------------------------------------------------
group_col <- detect_group_col(metrics_long)
if (is.na(group_col)) {
message("WARNING: no pude detectar columna de grupo demográfico. Dejo group='ALL'.")
metrics_long <- metrics_long %>% mutate(group = "ALL")
} else {
message("Columna de grupo detectada: ", group_col)
metrics_long <- metrics_long %>% mutate(group = as.character(.data[[group_col]]))
}
# ============================================================
# GRÁFICAS
# ============================================================
CITY_FOCUS <- "ALL"  # cambia si quieres filtrar
# (A) Grupos demográficos: facet por DIETA (CoCA/CoNA) y por COSTO (3)
plot_by_group <- function(df, city_focus = "ALL") {
d <- df %>%
filter(cost_type %in% c("hh_per_day", "pc_per_day", "per_1000kcal")) %>%
filter(!is.na(value))
if (city_focus != "ALL") d <- d %>% filter(ciudad == city_focus)
ggplot(d, aes(x = fecha, y = value, group = group, color = group)) +
geom_line(linewidth = 0.8, alpha = 0.9) +
facet_grid(metric ~ cost_type, scales = "free_y") +
labs(
title = "Evolución temporal por grupo demográfico (facet: dieta x costo)",
x = NULL, y = "Costo"
) +
theme_minimal(base_size = 12) +
theme(legend.position = "right")
}
p_group <- plot_by_group(metrics_long, CITY_FOCUS)
ggsave(
filename = file.path(fig_dir, paste0("A_group_facet_diet_x_cost_", CITY_FOCUS, ".png")),
plot = p_group, width = 13, height = 8, dpi = 300
)
# ============================================================
# Least-cost metrics (CoCA / CoNA) FoodpriceR::HCost - Monthly
# + Gráficas:
#   (1) CoCA y CoNA por grupo demográfico (líneas = grupos)
#   (2) CoCA vs CoNA por 3 costos (líneas = CoCA/CoNA; facet = costo)
# ============================================================
# ============================================================
# CoCA / CoNA (FoodpriceR::HCost)
# Estructura estilo Dani (listas CoCA/CoNA) +:
#  - source(00_config.R)
#  - logging (errores reales)
#  - alineación de nutrientes según EER/EER_LL/UL
#  - 3 costos: hh_per_day, pc_per_day, per_1000kcal
#  - gráficas:
#      A) grupos demográficos facet: dieta x costo
#      B) CoCA vs CoNA facet por costo
# ============================================================
# ------------------------------------------------------------
# Paquetes
# ------------------------------------------------------------
suppressPackageStartupMessages({
library(tidyverse)
library(FoodpriceR)
library(lubridate)
})
# ------------------------------------------------------------
# Directorios
# ------------------------------------------------------------
base_dir <- "C:/Users/danie/OneDrive/Escritorio/Least-cost-diets-and-affordability/Proyecto Interno/"
out_dir <- file.path(base_dir, "working-papers/working-paper-ipc/output/least_cost_metrics")
dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)
tmp_dir <- file.path(out_dir, "tmp")
dir.create(tmp_dir, recursive = TRUE, showWarnings = FALSE)
fig_dir <- file.path(out_dir, "figures")
dir.create(fig_dir, recursive = TRUE, showWarnings = FALSE)
log_dir <- file.path(out_dir, "logs")
dir.create(log_dir, recursive = TRUE, showWarnings = FALSE)
# ------------------------------------------------------------
# 1) Config (FoodpriceR requirements)
# ------------------------------------------------------------
source(file.path(base_dir, "working-papers/working-paper-ipc/least-cost-metrics/00_config.R"))
stopifnot(exists("EER"), exists("EER_LL"), exists("UL"))
Household_obj <- if (exists("Household")) Household else FoodpriceR::Household
# ------------------------------------------------------------
# 2) Panel (RDS)
# ------------------------------------------------------------
panel_path <- "C:/Users/danie/OneDrive/Escritorio/Least-cost-diets-and-affordability/Proyecto Interno/working-papers/working-paper-ipc/output/least_cost_metrics/tmp/panel_city_month_food_1999_2025.rds"
stopifnot(file.exists(panel_path))
panel <- readRDS(panel_path)
panel <- panel %>%
mutate(
ciudad = as.character(ciudad),
fecha  = case_when(
inherits(fecha, "Date") ~ fecha,
is.numeric(fecha)       ~ as.Date(fecha, origin = "1970-01-01"),
TRUE                    ~ as.Date(fecha)
)
)
# ------------------------------------------------------------
# Vectores de ciudad y fecha
# ------------------------------------------------------------
city_vector <- sort(unique(panel$ciudad))
date_vector <- sort(unique(panel$fecha))
# ------------------------------------------------------------
# Columnas nutricionales (lo que está en tu panel, luego alineamos)
# ------------------------------------------------------------
nutr_cols <- c(
"Energy","Protein","Lipids","Carbohydrates","VitaminC","Folate","VitaminA",
"Thiamine","Riboflavin","Niacin","VitaminB12","Magnesium","Phosphorus",
"Sodium","Calcium","Iron","Zinc"
)
# ------------------------------------------------------------
# Alineación: qué nutrientes exige el config (EER/EER_LL/UL)
# ------------------------------------------------------------
get_nutrient_names <- function(x) {
if (is.null(x)) return(character(0))
if (is.vector(x) && !is.null(names(x))) return(names(x))
if (is.data.frame(x) || is.matrix(x)) {
if (!is.null(colnames(x))) return(colnames(x))
if (!is.null(rownames(x))) return(rownames(x))
}
character(0)
}
req_EER    <- get_nutrient_names(EER)
req_EER_LL <- get_nutrient_names(EER_LL)
req_UL     <- get_nutrient_names(UL)
required_nutrients <- Reduce(intersect, list(req_EER, req_EER_LL, req_UL))
if (length(required_nutrients) == 0) required_nutrients <- req_EER
if (length(required_nutrients) == 0) required_nutrients <- nutr_cols
message("Nutrientes requeridos (según config): ", paste(required_nutrients, collapse = ", "))
# ------------------------------------------------------------
# Helpers: detectar columna de grupo y columnas de costo
# ------------------------------------------------------------
detect_group_col <- function(df) {
nms <- names(df)
cand <- nms[grepl("group|member|demo|hh|sex|age", nms, ignore.case = TRUE)]
if (length(cand) >= 1) return(cand[1])
ok <- setdiff(nms, c("ciudad","fecha","metric","cost_type","value","cost_raw"))
for (x in ok) {
if (is.character(df[[x]]) || is.factor(df[[x]])) return(x)
}
NA_character_
}
detect_cost_cols <- function(df) {
nms <- names(df)
num_cols <- nms[vapply(df, is.numeric, logical(1))]
num_cols <- setdiff(num_cols, c("Serving"))
score <- sapply(num_cols, function(x) {
s <- 0
s <- s + 5 * grepl("capita|per_cap|pc", x, ignore.case = TRUE)
s <- s + 5 * grepl("1000\\s*kcal|1000kcal", x, ignore.case = TRUE)
s <- s + 2 * grepl("day|per_day|dia", x, ignore.case = TRUE)
s <- s + 1 * grepl("cost|price|value|cop|usd", x, ignore.case = TRUE)
s
})
num_cols[order(score, decreasing = TRUE)]
}
standardize_costs_long <- function(df_model, metric_name, ciudad, fecha,
hh_size = NA_real_, hh_kcal = NA_real_) {
df_model <- as_tibble(df_model) %>%
mutate(ciudad = ciudad, fecha = fecha, metric = metric_name)
cost_candidates <- detect_cost_cols(df_model)
top3 <- head(cost_candidates, 3)
# Caso: ya vienen 3 costos
if (length(top3) >= 3) {
out <- df_model %>%
pivot_longer(all_of(top3), names_to = "cost_raw", values_to = "value") %>%
mutate(
cost_type = case_when(
grepl("capita|per_cap|pc", cost_raw, ignore.case = TRUE) ~ "pc_per_day",
grepl("1000\\s*kcal|1000kcal", cost_raw, ignore.case = TRUE) ~ "per_1000kcal",
TRUE ~ "hh_per_day"
)
) %>%
dplyr::select(ciudad, fecha, metric, cost_type, value, everything())
return(out)
}
# Caso: construir 3 costos desde 1
base_col <- if (length(cost_candidates) >= 1) cost_candidates[1] else NA_character_
if (is.na(base_col)) return(NULL)
tmp <- df_model %>%
mutate(
hh_per_day = .data[[base_col]],
pc_per_day = if (!is.na(hh_size) && is.numeric(hh_size) && hh_size > 0) hh_per_day / hh_size else NA_real_,
per_1000kcal = if (!is.na(hh_kcal) && is.numeric(hh_kcal) && hh_kcal > 0) (hh_per_day / hh_kcal) * 1000 else NA_real_
)
tmp %>%
pivot_longer(c("hh_per_day","pc_per_day","per_1000kcal"),
names_to = "cost_type", values_to = "value") %>%
dplyr::select(ciudad, fecha, metric, cost_type, value, everything())
}
# ------------------------------------------------------------
# Función Dani-style: construir panel.aux + HCost + devuelve CoCA/CoNA
#   (con alineación de nutrientes + logging de “dietas listas”)
# ------------------------------------------------------------
compute_hcost_city_date <- function(city.x, date.x, panel) {
panel.aux <- panel %>%
filter(ciudad == city.x, fecha == date.x) %>%
dplyr::rename(
Energy         = energia_kcal,
Protein        = proteina_g,
Lipids         = lipidos_g,
Carbohydrates  = carbohidratos_totales_g,
VitaminC       = vitamina_c_mg,
Folate         = folatos_mcg,
VitaminA       = vitamina_a_er,
Thiamine       = tiamina_mg,
Riboflavin     = riboflavina_mg,
Niacin         = niacina_mg,
VitaminB12     = vitamina_b12_mcg,
Magnesium      = magnesio_mg,
Phosphorus     = fosforo_mg,
Sodium         = sodio_mg,
Calcium        = calcio_mg,
Iron           = hierro_mg,
Zinc           = zinc_mg
) %>%
transmute(
Food       = articulo,
Price_100g = precio_100g,
Serving    = 100,
across(all_of(nutr_cols), ~ .x)
) %>%
filter(
!is.na(Price_100g),
Price_100g > 0
)
if (nrow(panel.aux) == 0) return(NULL)
# Alineación: quedarnos SOLO con nutrientes requeridos y completos (evita NA que rompe LP)
keep_nutrients <- intersect(required_nutrients, names(panel.aux))
panel.aux <- panel.aux %>%
dplyr::select(Food, Price_100g, Serving, all_of(keep_nutrients)) %>%
filter(if_all(all_of(keep_nutrients), ~ !is.na(.x)))
if (nrow(panel.aux) < 5) return(NULL
)
# Correr HCost
hcost.aux <- FoodpriceR::HCost(
Data      = panel.aux,
ERR       = EER,
EER_LL    = EER_LL,
UL        = UL,
Household = Household_obj
)
coca <- hcost.aux$Model_CoCA %>% mutate(ciudad = city.x, fecha = date.x)
cona <- hcost.aux$Model_CoNA %>% mutate(ciudad = city.x, fecha = date.x)
if (is.null(hcost.aux$Model_CoCA) || is.null(hcost.aux$Model_CoNA)) return(NULL)
message("   -> LISTO dietas: CoCA y CoNA (raw)")
list(CoCA = coca, CoNA = cona)
}
# ------------------------------------------------------------
# Loop Dani-style + logging real de errores
# ------------------------------------------------------------
res_coca <- list()
res_cona <- list()
err_log  <- list()
k_coca <- 1
k_cona <- 1
k_err  <- 1
range(date_vector)
for (city.x in city_vector) {
for (date.x in date_vector) {
message("Procesando ciudad = ", city.x, " | fecha = ", as.character(date.x), " ...")
out <- tryCatch(
compute_hcost_city_date(city.x, date.x, panel),
error = function(e) {
err_log[[k_err]] <<- tibble(
ciudad = city.x,
fecha  = date.x,
error  = conditionMessage(e)
)
message("   -> ERROR HCost: ", conditionMessage(e))
k_err <<- k_err + 1
return(NULL)
}
)
if (is.null(out)) {
message("   -> NULL (sin datos suficientes / panel.aux vacío) en: ", city.x, " | ", as.character(date.x))
next
}
# Guardar raw
res_coca[[k_coca]] <- out$CoCA
res_cona[[k_cona]] <- out$CoNA
k_coca <- k_coca + 1
k_cona <- k_cona + 1
message("   -> OK: guardé CoCA y CoNA")
}
}
# ============================================================
# Least-cost metrics (CoCA / CoNA) FoodpriceR::HCost - Monthly
# + Gráficas:
#   (1) CoCA y CoNA por grupo demográfico (líneas = grupos)
#   (2) CoCA vs CoNA por 3 costos (líneas = CoCA/CoNA; facet = costo)
# ============================================================
suppressPackageStartupMessages({
library(tidyverse)
library(FoodpriceR)
library(lubridate)
})
# ------------------------------------------------------------
# Directorios
# ------------------------------------------------------------
base_dir <- "C:/Users/danie/OneDrive/Escritorio/Least-cost-diets-and-affordability/Proyecto Interno/"
out_dir <- file.path(base_dir, "working-papers/working-paper-ipc/output/least_cost_metrics")
dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)
tmp_dir <- file.path(out_dir, "tmp")
dir.create(tmp_dir, recursive = TRUE, showWarnings = FALSE)
afford_dir <- file.path(base_dir, "working-papers/working-paper-ipc/output/affordability")
dir.create(afford_dir, recursive = TRUE, showWarnings = FALSE)
fig_dir <- file.path(afford_dir, "figures")
dir.create(fig_dir, recursive = TRUE, showWarnings = FALSE)
log_dir <- file.path(afford_dir, "logs")
dir.create(log_dir, recursive = TRUE, showWarnings = FALSE)
# ------------------------------------------------------------
# 1) Config (FoodpriceR requirements)
# ------------------------------------------------------------
config_path <- file.path(base_dir, "working-papers/working-paper-ipc/least-cost-metrics/00_config.R")
stopifnot(file.exists(config_path))
source(config_path)
stopifnot(exists("EER"), exists("EER_LL"), exists("UL"))
Household_obj <- if (exists("Household")) Household else FoodpriceR::Household
# ------------------------------------------------------------
# 2) Panel (usa tu ruta; aquí prefiero RDS si existe)
# ------------------------------------------------------------
panel_rds <- "C:/Users/danie/OneDrive/Escritorio/Least-cost-diets-and-affordability/Proyecto Interno/working-papers/working-paper-ipc/output/least_cost_metrics/tmp/panel_city_month_food_1999_2025.rds"
panel_csv <- file.path(tmp_dir, "panel_city_month_food_1999_2025.csv")
if (file.exists(panel_rds)) {
panel <- readRDS(panel_rds)
} else {
panel <- read.csv(panel_csv, stringsAsFactors = FALSE)
}
panel <- panel %>%
dplyr::mutate(
fecha  = dplyr::case_when(
inherits(fecha, "Date") ~ fecha,
is.numeric(fecha)       ~ as.Date(fecha, origin = "1970-01-01"),
TRUE                    ~ as.Date(fecha)
),
ciudad = as.character(ciudad)
)
# ------------------------------------------------------------
# Vectores ciudad/fecha
# ------------------------------------------------------------
city_vector <- sort(unique(panel$ciudad))
date_vector <- sort(unique(panel$fecha))
# ------------------------------------------------------------
# Nutrientes (como en tu script)
# ------------------------------------------------------------
nutr_cols <- c(
"Energy","Protein","Lipids","Carbohydrates","VitaminC","Folate","VitaminA",
"Thiamine","Riboflavin","Niacin","VitaminB12","Magnesium","Phosphorus",
"Sodium","Calcium","Iron","Zinc"
)
# ------------------------------------------------------------
# Función HCost (FORZANDO dplyr::rename para evitar conflicto)
# ------------------------------------------------------------
compute_hcost_city_date <- function(city.x, date.x, panel) {
panel.aux <- panel %>%
dplyr::filter(ciudad == city.x, fecha == date.x) %>%
dplyr::rename(
Energy          = energia_kcal,
Protein         = proteina_g,
Lipids          = lipidos_g,
Carbohydrates   = carbohidratos_totales_g,
VitaminC        = vitamina_c_mg,
Folate          = folatos_mcg,
VitaminA        = vitamina_a_er,
Thiamine        = tiamina_mg,
Riboflavin      = riboflavina_mg,
Niacin          = niacina_mg,
VitaminB12      = vitamina_b12_mcg,
Magnesium       = magnesio_mg,
Phosphorus      = fosforo_mg,
Sodium          = sodio_mg,
Calcium         = calcio_mg,
Iron            = hierro_mg,
Zinc            = zinc_mg
) %>%
dplyr::transmute(
Food       = articulo,
Price_100g = precio_100g,
Serving    = 100,
dplyr::across(dplyr::all_of(nutr_cols), ~ .x)
) %>%
dplyr::filter(
!is.na(Price_100g),
!is.na(Energy),
Price_100g > 0,
Energy > 0
)
if (nrow(panel.aux) == 0) return(NULL)
hcost.aux <- FoodpriceR::HCost(
Data      = panel.aux,
ERR       = EER,
EER_LL    = EER_LL,
UL        = UL,
Household = Household_obj
)
coca <- hcost.aux$Model_CoCA %>% dplyr::mutate(ciudad = city.x, fecha = date.x, dieta = "CoCA")
cona <- hcost.aux$Model_CoNA %>% dplyr::mutate(ciudad = city.x, fecha = date.x, dieta = "CoNA")
list(CoCA = coca, CoNA = cona)
}
# ------------------------------------------------------------
# Loop + logging
# ------------------------------------------------------------
res_coca <- list()
res_cona <- list()
err_log  <- list()
k_coca <- 1
k_cona <- 1
k_err  <- 1
for (city.x in city_vector) {
for (date.x in date_vector) {
message("Procesando ciudad = ", city.x, " | fecha = ", as.character(date.x), " ...")
out <- tryCatch(
compute_hcost_city_date(city.x, date.x, panel),
error = function(e) {
err_log[[k_err]] <<- tibble(
ciudad = city.x,
fecha  = date.x,
error  = conditionMessage(e)
)
message("   -> ERROR HCost: ", conditionMessage(e))
k_err <<- k_err + 1
return(NULL)
}
)
if (is.null(out)) {
message("   -> NULL (sin datos suficientes) en: ", city.x, " | ", as.character(date.x))
next
}
res_coca[[k_coca]] <- out$CoCA
res_cona[[k_cona]] <- out$CoNA
k_coca <- k_coca + 1
k_cona <- k_cona + 1
message("   -> LISTO dietas: CoCA y CoNA")
}
}
View(Household_obj)
