)
}
# --- Loop para imprimir gráficos por sexo y por edad ---
for (sx in levels(as.factor(overall_cona$Sex))) {
for (agx in overall_cona %>% filter(Sex == sx) %>%
mutate(Ages = as.factor(as.character(Demo_Group))) %>%
dplyr::select(Ages) %>% pull() %>% levels()) {
p = (plot_cona_band(overall_cona, sx, agx))
ggsave(
filename = paste0("estimadores-banrep/CALI/validar/cona/cona_comparacion_", sx,"_",agx, ".png"),
plot = p,
width = 16,
height = 12,
dpi = 300
)
}
}
plot_cona_band <- function(data, sexo, age) {
data_sexo <- data %>% filter(Sex == sexo & Demo_Group == age)
# Pivotar para columnas Q1, Q2, Q3
data_wide <- data_sexo %>%
select(fecha, Demo_Group, escenario, cost_day) %>%
pivot_wider(names_from = escenario, values_from = cost_day)
data_wide$fecha = as.Date(data_wide$fecha)
ggplot(data_wide, aes(x = fecha, group = Demo_Group)) +
geom_ribbon(aes(ymin = precio_q1_100g,
ymax = precio_q3_100g),
fill = "red", alpha = 0.15) +  # Banda roja transparente
geom_line(aes(y = precio_q1_100g),
color = "red", linetype = 2, size = 0.6) +  # Q1 roja punteada
geom_line(aes(y = precio_q3_100g),
color = "red", linetype = 2, size = 0.6) +  # Q3 roja punteada
geom_line(aes(y = precio_q2_100g), color = "black", size = 1) +  # Q2 negra sólida
geom_line(aes(y = precio_100g), color = "green", size = 1) +  # Q2 negra sólida
facet_wrap(~ Demo_Group, scales = "free_y", ncol = 3) +
scale_x_date(date_labels = "%Y-%m", date_breaks = "6 months") +
labs(
title = paste("CoNA - Evolución del costo diario con banda entre Q1 y Q3 (",
sexo, " - ", age ,")", sep = ""),
x = "Fecha",
y = "Costo diario (COP)"
) +
theme_bw(base_size = 14) +
theme(
axis.text.x = element_text(angle = 45, hjust = 1),
panel.grid.minor = element_blank(),
legend.position = "none"
)
}
# --- Loop para imprimir gráficos por sexo y por edad ---
for (sx in levels(as.factor(overall_cona$Sex))) {
for (agx in overall_cona %>% filter(Sex == sx) %>%
mutate(Ages = as.factor(as.character(Demo_Group))) %>%
dplyr::select(Ages) %>% pull() %>% levels()) {
p = (plot_cona_band(overall_cona, sx, agx))
ggsave(
filename = paste0("estimadores-banrep/CALI/Resultados-09-2025/validar/cona/cona_comparacion_", sx,"_",agx, ".png"),
plot = p,
width = 16,
height = 12,
dpi = 300
)
}
}
sipsa_cona = readxl::read_excel("estimadores-banrep/CALI/Resultados-09-2025/input/sipsa_cona_cali.csv")
dane_cona  <- read_excel("estimadores-banrep/CALI/Resultados-10-2025/estimadores-DANE/cona/291025_dane_cona_cali.xlsx") %>%
select(-c("Food", "quantity"))
dane_cona2 = readxl::read_excel("estimadores-banrep/CALI/Resultados-09-2025/estimadores-DANE/010925_dane_cona_cali.csv")
head(dane_cona)
head(dane_cona2)
# Cargar base de datos
input_cali_hat <- read.csv("estimadores-banrep/CALI/Resultados-09-2025/estimadores-DANE/input/010925_comp_price_data_cali.csv")
# Selección y recodificación de nutrientes
input_cali_hat <- input_cali_hat %>%
rename(
Energy = energia_kcal,
Protein = proteina_g,
Lipids = lipidos_g,
Carbohydrates = carbohidratos_totales_g,
VitaminC = vitamina_c_mg,
Folate = folatos_mcg,
VitaminA = vitamina_a_er,
Thiamine = tiamina_mg,
Riboflavin = riboflavina_mg,
Niacin = niacina_mg,
VitaminB12 = vitamina_b12_mcg,
Magnesium = magnesio_mg,
Phosphorus = fosforo_mg,
Sodium = sodio_mg,
Calcium = calcio_mg,
Iron = hierro_mg,
Zinc = zinc_mg
) %>%
select(ano, mes_num, articulo , precio_100g, codigo_tcac,
Energy, Protein, Lipids, Carbohydrates, VitaminC, Folate, VitaminA,
Thiamine, Riboflavin, Niacin, VitaminB12, Magnesium, Phosphorus,
Sodium, Calcium, Iron, Zinc)
# Vector de nombres para las variables de precio en los tres escenarios
escenarios <- c("precio_100g")
# Inicializar resultados
resultados <- list()
for (k in seq_along(escenarios)) {
var_precio <- escenarios[k]
message(paste0("Procesando escenario ", k, ": ", var_precio))
data_k <- input_cali_hat %>%
mutate(
Food = articulo,
Price_100g = .data[[var_precio]],
Serving = 100,
fecha = as.Date(paste(ano, mes_num, "01", sep = "-"))
)
fechas_k <- seq(min(data_k$fecha, na.rm = TRUE),
max(data_k$fecha, na.rm = TRUE),
by = "month")
output_k <- vector("list", length(fechas_k))
for (t in seq_along(fechas_k)) {
message(paste0(" - Fecha ", t, ": ", fechas_k[t]))
df.aux <- data_k %>%
filter(fecha == fechas_k[t]) %>%
filter(!is.na(Price_100g), !is.na(Energy))
# Ad hoc: por simplcidad, voy a promediar para evitar duplicados
# pero un procedimiento más riguroso precisa otro mapeo
df.aux <- df.aux %>% group_by(Food) %>%
summarise(
Price_100g = mean(Price_100g, na.rm = TRUE),
Serving = 100,
Energy = mean(Energy, na.rm = TRUE),
Protein = mean(Protein, na.rm = TRUE),
Lipids = mean(Lipids, na.rm = TRUE),
Carbohydrates = mean(Carbohydrates, na.rm = TRUE),
VitaminC = mean(VitaminC, na.rm = TRUE),
Folate = mean(Folate, na.rm = TRUE),
VitaminA = mean(VitaminA, na.rm = TRUE),
Thiamine = mean(Thiamine, na.rm = TRUE),
Riboflavin = mean(Riboflavin, na.rm = TRUE),
Niacin = mean(Niacin, na.rm = TRUE),
VitaminB12 = mean(VitaminB12, na.rm = TRUE),
Magnesium = mean(Magnesium, na.rm = TRUE),
Phosphorus = mean(Phosphorus, na.rm = TRUE),
Sodium = mean(Sodium, na.rm = TRUE),
Calcium = mean(Calcium, na.rm = TRUE),
Iron = mean(Iron, na.rm = TRUE),
Zinc = mean(Zinc, na.rm = TRUE),
)
message(paste0("   Número de alimentos en la fecha: ", nrow(df.aux)))
if (nrow(df.aux) == 0) {
message("   No hay datos para esta fecha, asignando NA")
output_k[[t]] <- NA
next
}
tryCatch({
cona.aux <- FoodpriceR::CoNA(data = df.aux,
EER_LL = EER_LL,
UL = UL)
output_k[[t]] <- cona.aux$cost
output_k[[t]]$fecha = fechas_k[t]
output_k[[t]]$escenario = var_precio
}, error = function(e) {
warning(paste("Error en CoCA para fecha", fechas_k[t], ":", e$message))
output_k[[t]] <- data.frame(Food = NA,
quantity = NA,
Demo_Group = NA,
Sex = NA,
cost_day = NA,
Cost_1000kcal = NA)
output_k[[t]]$fecha = fechas_k[t]
output_k[[t]]$escenario = var_precio
})
}
resultados[[k]] <- output_k
message(paste0("Escenario ", k, " terminado.\n"))
}
resultados_cona <- do.call(rbind, resultados[[1]])
print(head(resultados_cona, 20))
head(dane_cona2)
View(resultados_cona)
# Cargar base de datos
input_cali_hat <- read.csv("estimadores-banrep/CALI/Resultados-10-2025/estimadores-DANE/input/291025_comp_price_data_cali.csv")
resultados_cona2 = resultados_cona
View(resultados_cona2 )
# Selección y recodificación de nutrientes
input_cali_hat <- input_cali_hat %>%
rename(
Energy = energia_kcal,
Protein = proteina_g,
Lipids = lipidos_g,
Carbohydrates = carbohidratos_totales_g,
VitaminC = vitamina_c_mg,
Folate = folatos_mcg,
VitaminA = vitamina_a_er,
Thiamine = tiamina_mg,
Riboflavin = riboflavina_mg,
Niacin = niacina_mg,
VitaminB12 = vitamina_b12_mcg,
Magnesium = magnesio_mg,
Phosphorus = fosforo_mg,
Sodium = sodio_mg,
Calcium = calcio_mg,
Iron = hierro_mg,
Zinc = zinc_mg
) %>%
select(ano, mes_num, articulo , precio_100g, codigo_tcac,
Energy, Protein, Lipids, Carbohydrates, VitaminC, Folate, VitaminA,
Thiamine, Riboflavin, Niacin, VitaminB12, Magnesium, Phosphorus,
Sodium, Calcium, Iron, Zinc)
# Vector de nombres para las variables de precio en los tres escenarios
escenarios <- c("precio_100g")
# Inicializar resultados
resultados <- list()
for (k in seq_along(escenarios)) {
var_precio <- escenarios[k]
message(paste0("Procesando escenario ", k, ": ", var_precio))
data_k <- input_cali_hat %>%
mutate(
Food = articulo,
Price_100g = .data[[var_precio]],
Serving = 100,
fecha = as.Date(paste(ano, mes_num, "01", sep = "-"))
)
fechas_k <- seq(min(data_k$fecha, na.rm = TRUE),
max(data_k$fecha, na.rm = TRUE),
by = "month")
output_k <- vector("list", length(fechas_k))
for (t in seq_along(fechas_k)) {
message(paste0(" - Fecha ", t, ": ", fechas_k[t]))
df.aux <- data_k %>%
filter(fecha == fechas_k[t]) %>%
filter(!is.na(Price_100g), !is.na(Energy))
# Ad hoc: por simplcidad, voy a promediar para evitar duplicados
# pero un procedimiento más riguroso precisa otro mapeo
df.aux <- df.aux %>% group_by(Food) %>%
summarise(
Price_100g = mean(Price_100g, na.rm = TRUE),
Serving = 100,
Energy = mean(Energy, na.rm = TRUE),
Protein = mean(Protein, na.rm = TRUE),
Lipids = mean(Lipids, na.rm = TRUE),
Carbohydrates = mean(Carbohydrates, na.rm = TRUE),
VitaminC = mean(VitaminC, na.rm = TRUE),
Folate = mean(Folate, na.rm = TRUE),
VitaminA = mean(VitaminA, na.rm = TRUE),
Thiamine = mean(Thiamine, na.rm = TRUE),
Riboflavin = mean(Riboflavin, na.rm = TRUE),
Niacin = mean(Niacin, na.rm = TRUE),
VitaminB12 = mean(VitaminB12, na.rm = TRUE),
Magnesium = mean(Magnesium, na.rm = TRUE),
Phosphorus = mean(Phosphorus, na.rm = TRUE),
Sodium = mean(Sodium, na.rm = TRUE),
Calcium = mean(Calcium, na.rm = TRUE),
Iron = mean(Iron, na.rm = TRUE),
Zinc = mean(Zinc, na.rm = TRUE),
)
message(paste0("   Número de alimentos en la fecha: ", nrow(df.aux)))
if (nrow(df.aux) == 0) {
message("   No hay datos para esta fecha, asignando NA")
output_k[[t]] <- NA
next
}
tryCatch({
cona.aux <- FoodpriceR::CoNA(data = df.aux,
EER_LL = EER_LL,
UL = UL)
output_k[[t]] <- cona.aux$cost
output_k[[t]]$fecha = fechas_k[t]
output_k[[t]]$escenario = var_precio
}, error = function(e) {
warning(paste("Error en CoCA para fecha", fechas_k[t], ":", e$message))
output_k[[t]] <- data.frame(Food = NA,
quantity = NA,
Demo_Group = NA,
Sex = NA,
cost_day = NA,
Cost_1000kcal = NA)
output_k[[t]]$fecha = fechas_k[t]
output_k[[t]]$escenario = var_precio
})
}
resultados[[k]] <- output_k
message(paste0("Escenario ", k, " terminado.\n"))
}
resultados_cona <- do.call(rbind, resultados[[1]])
print(head(resultados_cona, 20))
# Definir directorio de trabajo
setwd("C:/Users/Portatil/Desktop/Least-cost-diets-and-affordability/Proyecto Interno")
# Cargar base de datos
input_cali_hat <- read.csv("estimadores-banrep/CALI/Resultados-09-2025/estimadores-DANE/input/010925_comp_price_data_cali.csv")
View(input_cali_hat)
# Cargar base de datos
input_cali_hat2 <- read.csv("estimadores-banrep/CALI/Resultados-10-2025/estimadores-DANE/input/291025_comp_price_data_cali.csv")
head(input_cali_hat2 , 20)
View(input_cali_hat2 )
# Cargar base de datos
input_cali_hat <- read.csv("estimadores-banrep/CALI/Resultados-09-2025/estimadores-DANE/input/010925_comp_price_data_cali.csv")
# Selección y recodificación de nutrientes
input_cali_hat <- input_cali_hat %>%
rename(
Energy = energia_kcal,
Protein = proteina_g,
Lipids = lipidos_g,
Carbohydrates = carbohidratos_totales_g,
VitaminC = vitamina_c_mg,
Folate = folatos_mcg,
VitaminA = vitamina_a_er,
Thiamine = tiamina_mg,
Riboflavin = riboflavina_mg,
Niacin = niacina_mg,
VitaminB12 = vitamina_b12_mcg,
Magnesium = magnesio_mg,
Phosphorus = fosforo_mg,
Sodium = sodio_mg,
Calcium = calcio_mg,
Iron = hierro_mg,
Zinc = zinc_mg
) %>%
select(ano, mes_num, articulo , precio_100g, codigo_tcac,
Energy, Protein, Lipids, Carbohydrates, VitaminC, Folate, VitaminA,
Thiamine, Riboflavin, Niacin, VitaminB12, Magnesium, Phosphorus,
Sodium, Calcium, Iron, Zinc)
# Vector de nombres para las variables de precio en los tres escenarios
escenarios <- c("precio_100g")
# Inicializar resultados
resultados <- list()
for (k in seq_along(escenarios)) {
var_precio <- escenarios[k]
message(paste0("Procesando escenario ", k, ": ", var_precio))
data_k <- input_cali_hat %>%
mutate(
Food = articulo,
Price_100g = .data[[var_precio]],
Serving = 100,
fecha = as.Date(paste(ano, mes_num, "01", sep = "-"))
)
fechas_k <- seq(min(data_k$fecha, na.rm = TRUE),
max(data_k$fecha, na.rm = TRUE),
by = "month")
output_k <- vector("list", length(fechas_k))
for (t in seq_along(fechas_k)) {
message(paste0(" - Fecha ", t, ": ", fechas_k[t]))
df.aux <- data_k %>%
filter(fecha == fechas_k[t]) %>%
filter(!is.na(Price_100g), !is.na(Energy))
# Ad hoc: por simplcidad, voy a promediar para evitar duplicados
# pero un procedimiento más riguroso precisa otro mapeo
df.aux <- df.aux %>% group_by(Food) %>%
summarise(
Price_100g = mean(Price_100g, na.rm = TRUE),
Serving = 100,
Energy = mean(Energy, na.rm = TRUE),
Protein = mean(Protein, na.rm = TRUE),
Lipids = mean(Lipids, na.rm = TRUE),
Carbohydrates = mean(Carbohydrates, na.rm = TRUE),
VitaminC = mean(VitaminC, na.rm = TRUE),
Folate = mean(Folate, na.rm = TRUE),
VitaminA = mean(VitaminA, na.rm = TRUE),
Thiamine = mean(Thiamine, na.rm = TRUE),
Riboflavin = mean(Riboflavin, na.rm = TRUE),
Niacin = mean(Niacin, na.rm = TRUE),
VitaminB12 = mean(VitaminB12, na.rm = TRUE),
Magnesium = mean(Magnesium, na.rm = TRUE),
Phosphorus = mean(Phosphorus, na.rm = TRUE),
Sodium = mean(Sodium, na.rm = TRUE),
Calcium = mean(Calcium, na.rm = TRUE),
Iron = mean(Iron, na.rm = TRUE),
Zinc = mean(Zinc, na.rm = TRUE),
)
message(paste0("   Número de alimentos en la fecha: ", nrow(df.aux)))
if (nrow(df.aux) == 0) {
message("   No hay datos para esta fecha, asignando NA")
output_k[[t]] <- NA
next
}
tryCatch({
cona.aux <- FoodpriceR::CoNA(data = df.aux,
EER_LL = EER_LL,
UL = UL)
output_k[[t]] <- cona.aux$cost
output_k[[t]]$fecha = fechas_k[t]
output_k[[t]]$escenario = var_precio
}, error = function(e) {
warning(paste("Error en CoCA para fecha", fechas_k[t], ":", e$message))
output_k[[t]] <- data.frame(Food = NA,
quantity = NA,
Demo_Group = NA,
Sex = NA,
cost_day = NA,
Cost_1000kcal = NA)
output_k[[t]]$fecha = fechas_k[t]
output_k[[t]]$escenario = var_precio
})
}
resultados[[k]] <- output_k
message(paste0("Escenario ", k, " terminado.\n"))
}
resultados_conav1 <- do.call(rbind, resultados[[1]])
# Cargar base de datos
input_cali_hat <- read.csv("estimadores-banrep/CALI/Resultados-10-2025/estimadores-DANE/input/291025_comp_price_data_cali.csv")
# Selección y recodificación de nutrientes
input_cali_hat <- input_cali_hat %>%
rename(
Energy = energia_kcal,
Protein = proteina_g,
Lipids = lipidos_g,
Carbohydrates = carbohidratos_totales_g,
VitaminC = vitamina_c_mg,
Folate = folatos_mcg,
VitaminA = vitamina_a_er,
Thiamine = tiamina_mg,
Riboflavin = riboflavina_mg,
Niacin = niacina_mg,
VitaminB12 = vitamina_b12_mcg,
Magnesium = magnesio_mg,
Phosphorus = fosforo_mg,
Sodium = sodio_mg,
Calcium = calcio_mg,
Iron = hierro_mg,
Zinc = zinc_mg
) %>%
select(ano, mes_num, articulo , precio_100g, codigo_tcac,
Energy, Protein, Lipids, Carbohydrates, VitaminC, Folate, VitaminA,
Thiamine, Riboflavin, Niacin, VitaminB12, Magnesium, Phosphorus,
Sodium, Calcium, Iron, Zinc)
# Vector de nombres para las variables de precio en los tres escenarios
escenarios <- c("precio_100g")
# Inicializar resultados
resultados <- list()
for (k in seq_along(escenarios)) {
var_precio <- escenarios[k]
message(paste0("Procesando escenario ", k, ": ", var_precio))
data_k <- input_cali_hat %>%
mutate(
Food = articulo,
Price_100g = .data[[var_precio]],
Serving = 100,
fecha = as.Date(paste(ano, mes_num, "01", sep = "-"))
)
fechas_k <- seq(min(data_k$fecha, na.rm = TRUE),
max(data_k$fecha, na.rm = TRUE),
by = "month")
output_k <- vector("list", length(fechas_k))
for (t in seq_along(fechas_k)) {
message(paste0(" - Fecha ", t, ": ", fechas_k[t]))
df.aux <- data_k %>%
filter(fecha == fechas_k[t]) %>%
filter(!is.na(Price_100g), !is.na(Energy))
# Ad hoc: por simplcidad, voy a promediar para evitar duplicados
# pero un procedimiento más riguroso precisa otro mapeo
df.aux <- df.aux %>% group_by(Food) %>%
summarise(
Price_100g = mean(Price_100g, na.rm = TRUE),
Serving = 100,
Energy = mean(Energy, na.rm = TRUE),
Protein = mean(Protein, na.rm = TRUE),
Lipids = mean(Lipids, na.rm = TRUE),
Carbohydrates = mean(Carbohydrates, na.rm = TRUE),
VitaminC = mean(VitaminC, na.rm = TRUE),
Folate = mean(Folate, na.rm = TRUE),
VitaminA = mean(VitaminA, na.rm = TRUE),
Thiamine = mean(Thiamine, na.rm = TRUE),
Riboflavin = mean(Riboflavin, na.rm = TRUE),
Niacin = mean(Niacin, na.rm = TRUE),
VitaminB12 = mean(VitaminB12, na.rm = TRUE),
Magnesium = mean(Magnesium, na.rm = TRUE),
Phosphorus = mean(Phosphorus, na.rm = TRUE),
Sodium = mean(Sodium, na.rm = TRUE),
Calcium = mean(Calcium, na.rm = TRUE),
Iron = mean(Iron, na.rm = TRUE),
Zinc = mean(Zinc, na.rm = TRUE),
)
message(paste0("   Número de alimentos en la fecha: ", nrow(df.aux)))
if (nrow(df.aux) == 0) {
message("   No hay datos para esta fecha, asignando NA")
output_k[[t]] <- NA
next
}
tryCatch({
cona.aux <- FoodpriceR::CoNA(data = df.aux,
EER_LL = EER_LL,
UL = UL)
output_k[[t]] <- cona.aux$cost
output_k[[t]]$fecha = fechas_k[t]
output_k[[t]]$escenario = var_precio
}, error = function(e) {
warning(paste("Error en CoCA para fecha", fechas_k[t], ":", e$message))
output_k[[t]] <- data.frame(Food = NA,
quantity = NA,
Demo_Group = NA,
Sex = NA,
cost_day = NA,
Cost_1000kcal = NA)
output_k[[t]]$fecha = fechas_k[t]
output_k[[t]]$escenario = var_precio
})
}
resultados[[k]] <- output_k
message(paste0("Escenario ", k, " terminado.\n"))
}
resultados_cona <- do.call(rbind, resultados[[1]])
whole = merge(resultados_cona, resultados_conav1)
View(whole)
resultados_cona <- do.call(rbind, resultados[[1]])
resultados_cona
resultados_conav1
whole = merge(resultados_cona, resultados_conav1)
View(whole)
whole = merge(resultados_cona, resultados_conav1, by = c("Demo_Group", "Sex", "fecha", "escenario"))
View(whole)
# Cargar base de datos
input_cali_hat <- read.csv("estimadores-banrep/CALI/Resultados-09-2025/estimadores-DANE/input/010925_comp_price_data_cali.csv")
# Cargar base de datos
input_cali_hat2 <- read.csv("estimadores-banrep/CALI/Resultados-10-2025/estimadores-DANE/input/291025_comp_price_data_cali.csv")
whole_input = merge(input_cali_hat, input_cali_hat2)
View(whole_input)
