##    y_t = spread_t - a0
##----------------------------------------------------------
reg_det <- lm(spread ~ 1, data = df)
y <- resid(reg_det)   # series used for TAR
Tn <- length(y)
##----------------------------------------------------------
## 2. Build TAR regression dataset for lag p
##----------------------------------------------------------
build_tar_df <- function(y, p = 0) {
y <- as.numeric(y)
Tn <- length(y)
dy   <- c(NA, diff(y))
y_l1 <- c(NA, y[-Tn])
# TAR indicator: I_t = 1{ y_{t-1} < 0 }
I <- ifelse(y_l1 < 0, 1, 0)
z1 <- I * y_l1
z2 <- (1 - I) * y_l1
dfm <- data.frame(dy = dy, z1 = z1, z2 = z2)
if (p > 0) {
for (j in 1:p) {
dfm[[paste0("dy_l", j)]] <- c(rep(NA, j), dy[1:(Tn - j)])
}
}
dfm <- dfm[complete.cases(dfm), , drop = FALSE]
if (nrow(dfm) < 20) stop("Insufficient observations after lagging.")
dfm
}
##----------------------------------------------------------
## 3. AIC/BIC as in Enders–Granger
##    AIC = T log(SSR) + 2n
##    BIC = T log(SSR) + n log(T)
##----------------------------------------------------------
ic_enders <- function(ssr, Tn, n_par) {
aic <- Tn * log(ssr) + 2 * n_par
bic <- Tn * log(ssr) + n_par * log(Tn)
list(AIC = aic, BIC = bic)
}
##----------------------------------------------------------
## 4. Estimate TAR model with tests:
##    - φ_μ (joint zero)
##    - Equality (ρ1 = ρ2)
##----------------------------------------------------------
estimate_linear_attractor <- function(y, p = 0) {
dfm <- build_tar_df(y, p = p)
rhs <- c("z1", "z2")
if (p > 0) rhs <- c(rhs, paste0("dy_l", 1:p))
fml <- as.formula(paste("dy ~ 0 +", paste(rhs, collapse = " + ")))
mod <- lm(fml, data = dfm)
s   <- summary(mod)
# unrestricted residuals
SSR_U <- sum(resid(mod)^2)
Tn_m  <- nrow(dfm)
kU    <- length(coef(mod))
#--------------------------------------------------------
# (A) Φμ statistic: H0: ρ1 = ρ2 = 0
#--------------------------------------------------------
if (p > 0) {
rhs_R <- paste0("dy_l", 1:p, collapse = " + ")
fml_R <- as.formula(paste("dy ~ 0 +", rhs_R))
} else {
fml_R <- dy ~ 0
}
mod_R <- lm(fml_R, data = dfm)
SSR_R <- sum(resid(mod_R)^2)
q <- 2     # number of restrictions
Phi_mu <- ((SSR_R - SSR_U)/q) / (SSR_U/(Tn_m - kU))
#--------------------------------------------------------
# (B) Equality test: H0: ρ1 = ρ2
#--------------------------------------------------------
dfm_eq <- dfm
dfm_eq$z_sum <- dfm_eq$z1 + dfm_eq$z2
rhs_eq <- c("z_sum")
if (p > 0) rhs_eq <- c(rhs_eq, paste0("dy_l", 1:p))
fml_eq <- as.formula(paste("dy ~ 0 +", paste(rhs_eq, collapse = " + ")))
mod_eq <- lm(fml_eq, data = dfm_eq)
an <- anova(mod_eq, mod)
F_equal <- an$F[2]
pF_equal <- an$`Pr(>F)`[2]
#--------------------------------------------------------
# t-stats and IC
#--------------------------------------------------------
coefs <- coef(s)
rho1  <- coefs["z1", "Estimate"]
trho1 <- coefs["z1", "t value"]
rho2  <- coefs["z2", "Estimate"]
trho2 <- coefs["z2", "t value"]
ic <- ic_enders(SSR_U, Tn_m, kU)
# Ljung–Box Q(4)
Q4 <- Box.test(resid(mod), lag = 4, type = "Ljung-Box", fitdf = kU)
list(
model   = mod,
p       = p,
rho1    = rho1,
t_rho1  = trho1,
rho2    = rho2,
t_rho2  = trho2,
Phi_mu  = Phi_mu,
F_equal = F_equal,
p_equal = pF_equal,
AIC     = ic$AIC,
BIC     = ic$BIC,
Q4      = as.numeric(Q4$statistic),
p_Q4    = Q4$p.value
)
}
##----------------------------------------------------------
## 5. Run TAR for p = 0 and p = 1
##----------------------------------------------------------
tar_p0 <- estimate_linear_attractor(y, p = 0)
tar_p1 <- estimate_linear_attractor(y, p = 1)
##----------------------------------------------------------
## 6. Display results (like Table 5)
##----------------------------------------------------------
results <- tibble(
model = c("TAR (p=0)", "TAR (p=1)"),
rho1  = c(tar_p0$rho1, tar_p1$rho1),
t_rho1 = c(tar_p0$t_rho1, tar_p1$t_rho1),
rho2  = c(tar_p0$rho2, tar_p1$rho2),
t_rho2 = c(tar_p0$t_rho2, tar_p1$t_rho2),
Phi_mu = c(tar_p0$Phi_mu, tar_p1$Phi_mu),
F_equal = c(tar_p0$F_equal, tar_p1$F_equal),
p_equal = c(tar_p0$p_equal, tar_p1$p_equal),
AIC = c(tar_p0$AIC, tar_p1$AIC),
BIC = c(tar_p0$BIC, tar_p1$BIC),
Q4  = c(tar_p0$Q4, tar_p1$Q4),
p_Q4 = c(tar_p0$p_Q4, tar_p1$p_Q4)
)
print(results, digits = 4)
tar_p1
tar_p0
dfm <- build_tar_df(y, p = p)
dfm
rhs <- c("z1", "z2")
if (p > 0) rhs <- c(rhs, paste0("dy_l", 1:p))
rhs
fml <- as.formula(paste("dy ~ 0 +", paste(rhs, collapse = " + ")))
fml
fml <- as.formula(paste("dy ~ 1 +", paste(rhs, collapse = " + ")))
mod <- lm(fml, data = dfm)
s   <- summary(mod)
s
fml <- as.formula(paste("dy ~ 0 +", paste(rhs, collapse = " + ")))
mod <- lm(fml, data = dfm)
s   <- summary(mod)
s
# unrestricted residuals
SSR_U <- sum(resid(mod)^2)
Tn_m  <- nrow(dfm)
kU    <- length(coef(mod))
if (p > 0) {
rhs_R <- paste0("dy_l", 1:p, collapse = " + ")
fml_R <- as.formula(paste("dy ~ 0 +", rhs_R))
} else {
fml_R <- dy ~ 0
}
fml_R
if (p > 0) {
rhs_R <- paste0("dy_l", 1:p, collapse = " + ")
fml_R <- as.formula(paste("dy ~ 0 +", rhs_R))
} else {
fml_R <- dy ~ 0
}
fml_R
dfm
mod_R <- lm(fml_R, data = dfm)
SSR_R <- sum(resid(mod_R)^2)
q <- 2     # number of restrictions
Phi_mu <- ((SSR_R - SSR_U)/q) / (SSR_U/(Tn_m - kU))
Phi_mu
dfm_eq <- dfm
dfm_eq$z_sum <- dfm_eq$z1 + dfm_eq$z2
rhs_eq <- c("z_sum")
if (p > 0) rhs_eq <- c(rhs_eq, paste0("dy_l", 1:p))
fml_eq <- as.formula(paste("dy ~ 0 +", paste(rhs_eq, collapse = " + ")))
mod_eq <- lm(fml_eq, data = dfm_eq)
an <- anova(mod_eq, mod)
F_equal <- an$F[2]
pF_equal <- an$`Pr(>F)`[2]
pF_equal
F_equal
tar_p0
dy_l1 <- c(NA, diff(y_l1))
dy_l1
# TAR indicator: I_t = 1{ y_{t-1} < 0 }
I <- ifelse(dy_l1 < 0, 1, 0)
I
z1 <- I * y_l1
z2 <- (1 - I) * y_l1
dfm <- data.frame(dy = dy, z1 = z1, z2 = z2)
if (p > 0) {
for (j in 1:p) {
dfm[[paste0("dy_l", j)]] <- c(rep(NA, j), dy[1:(Tn - j)])
}
}
dfm <- dfm[complete.cases(dfm), , drop = FALSE]
if (nrow(dfm) < 20) stop("Insufficient observations after lagging.")
dfm
build_tar_df <- function(y, p = 0) {
y <- as.numeric(y)
Tn <- length(y)
dy   <- c(NA, diff(y))
y_l1 <- c(NA, y[-Tn])
dy_l1 <- c(NA, diff(y_l1))
# TAR indicator: I_t = 1{ y_{t-1} < 0 }
I <- ifelse(dy_l1 < 0, 1, 0)
z1 <- I * y_l1
z2 <- (1 - I) * y_l1
dfm <- data.frame(dy = dy, z1 = z1, z2 = z2)
if (p > 0) {
for (j in 1:p) {
dfm[[paste0("dy_l", j)]] <- c(rep(NA, j), dy[1:(Tn - j)])
}
}
dfm <- dfm[complete.cases(dfm), , drop = FALSE]
if (nrow(dfm) < 20) stop("Insufficient observations after lagging.")
dfm
}
ic_enders <- function(ssr, Tn, n_par) {
aic <- Tn * log(ssr) + 2 * n_par
bic <- Tn * log(ssr) + n_par * log(Tn)
list(AIC = aic, BIC = bic)
}
estimate_linear_attractor <- function(y, p = 0) {
dfm <- build_tar_df(y, p = p)
rhs <- c("z1", "z2")
if (p > 0) rhs <- c(rhs, paste0("dy_l", 1:p))
fml <- as.formula(paste("dy ~ 0 +", paste(rhs, collapse = " + ")))
mod <- lm(fml, data = dfm)
s   <- summary(mod)
# unrestricted residuals
SSR_U <- sum(resid(mod)^2)
Tn_m  <- nrow(dfm)
kU    <- length(coef(mod))
#--------------------------------------------------------
# (A) Φμ statistic: H0: ρ1 = ρ2 = 0
#--------------------------------------------------------
if (p > 0) {
rhs_R <- paste0("dy_l", 1:p, collapse = " + ")
fml_R <- as.formula(paste("dy ~ 0 +", rhs_R))
} else {
fml_R <- dy ~ 0
}
mod_R <- lm(fml_R, data = dfm)
SSR_R <- sum(resid(mod_R)^2)
q <- 2     # number of restrictions
Phi_mu <- ((SSR_R - SSR_U)/q) / (SSR_U/(Tn_m - kU))
#--------------------------------------------------------
# (B) Equality test: H0: ρ1 = ρ2
#--------------------------------------------------------
dfm_eq <- dfm
dfm_eq$z_sum <- dfm_eq$z1 + dfm_eq$z2
rhs_eq <- c("z_sum")
if (p > 0) rhs_eq <- c(rhs_eq, paste0("dy_l", 1:p))
fml_eq <- as.formula(paste("dy ~ 0 +", paste(rhs_eq, collapse = " + ")))
mod_eq <- lm(fml_eq, data = dfm_eq)
an <- anova(mod_eq, mod)
F_equal <- an$F[2]
pF_equal <- an$`Pr(>F)`[2]
#--------------------------------------------------------
# t-stats and IC
#--------------------------------------------------------
coefs <- coef(s)
rho1  <- coefs["z1", "Estimate"]
trho1 <- coefs["z1", "t value"]
rho2  <- coefs["z2", "Estimate"]
trho2 <- coefs["z2", "t value"]
ic <- ic_enders(SSR_U, Tn_m, kU)
# Ljung–Box Q(4)
Q4 <- Box.test(resid(mod), lag = 4, type = "Ljung-Box", fitdf = kU)
list(
model   = mod,
p       = p,
rho1    = rho1,
t_rho1  = trho1,
rho2    = rho2,
t_rho2  = trho2,
Phi_mu  = Phi_mu,
F_equal = F_equal,
p_equal = pF_equal,
AIC     = ic$AIC,
BIC     = ic$BIC,
Q4      = as.numeric(Q4$statistic),
p_Q4    = Q4$p.value
)
}
tar_p0 <- estimate_linear_attractor(y, p = 0)
tar_p1 <- estimate_linear_attractor(y, p = 1)
tar_p1
tar_p0
p = 1
rhs <- c("z1", "z2")
if (p > 0) rhs <- c(rhs, paste0("dy_l", 1:p))
fml <- as.formula(paste("dy ~ 0 +", paste(rhs, collapse = " + ")))
fml
dfm
fml
dfm_eq <- dfm
dfm_eq
dfm_eq$z_sum <- dfm_eq$z1 + dfm_eq$z2
dfm_eq
rhs_eq <- c("z_sum")
if (p > 0) rhs_eq <- c(rhs_eq, paste0("dy_l", 1:p))
rhs_eq
fml_eq <- as.formula(paste("dy ~ 0 +", paste(rhs_eq, collapse = " + ")))
fml_eq
mod_eq <- lm(fml_eq, data = dfm_eq)
dfm <- build_tar_df(y, p = p)
rhs <- c("z1", "z2")
if (p > 0) rhs <- c(rhs, paste0("dy_l", 1:p))
fml <- as.formula(paste("dy ~ 0 +", paste(rhs, collapse = " + ")))
mod <- lm(fml, data = dfm)
s   <- summary(mod)
# unrestricted residuals
SSR_U <- sum(resid(mod)^2)
Tn_m  <- nrow(dfm)
kU    <- length(coef(mod))
if (p > 0) {
rhs_R <- paste0("dy_l", 1:p, collapse = " + ")
fml_R <- as.formula(paste("dy ~ 0 +", rhs_R))
} else {
fml_R <- dy ~ 0
}
mod_R <- lm(fml_R, data = dfm)
SSR_R <- sum(resid(mod_R)^2)
q <- 2     # number of restrictions
Phi_mu <- ((SSR_R - SSR_U)/q) / (SSR_U/(Tn_m - kU))
dfm_eq <- dfm
dfm_eq$z_sum <- dfm_eq$z1 + dfm_eq$z2
rhs_eq <- c("z_sum")
if (p > 0) rhs_eq <- c(rhs_eq, paste0("dy_l", 1:p))
fml_eq <- as.formula(paste("dy ~ 0 +", paste(rhs_eq, collapse = " + ")))
mod_eq <- lm(fml_eq, data = dfm_eq)
fml_eq
mod_eq <- lm(fml_eq, data = dfm_eq)
mod_eq
mod
an <- anova(mod_eq, mod)
F_equal <- an$F[2]
pF_equal <- an$`Pr(>F)`[2]
an
############################################################
## Enders & Granger (1998)
## Dickey–Fuller models (Φμ-style regression sin umbral)
## Quarterly interest-rate differential 1958Q1–1994Q1
## Output: rho1 (φ), t-stat, AIC, BIC, Q(4)
############################################################
library(tidyverse)
library(lubridate)
library(readxl)
##----------------------------------------------------------
## 0. Load data and build quarterly dates + spread
##----------------------------------------------------------
setwd("C:/Users/sergio.barona/Desktop/Least-cost-diets-and-affordability/Proyecto Interno/")
dataset <- read_excel(
"working-papers/working-paper-aecm/literature/enders_granger/dataset_enders.xlsx"
)
n_obs <- nrow(dataset)
dates_q <- seq.Date(
from = as.Date("1958-01-01"),
by   = "quarter",
length.out = n_obs
)
df <- dataset %>%
mutate(
date   = dates_q,
spread = r_10 - r_short   # long - short
)
##----------------------------------------------------------
## 1. Step 1: Remove deterministic part (constant)
##    y_t = spread_t - a0
##    (igual que en los modelos TAR / Momentum)
##----------------------------------------------------------
reg_det <- lm(spread ~ 1, data = df)
y <- resid(reg_det)      # serie "y_t" para el DF
Tn <- length(y)
##----------------------------------------------------------
## 2. AIC/BIC como en Enders–Granger
##    AIC = T log(SSR) + 2n
##    BIC = T log(SSR) + n log(T)
##----------------------------------------------------------
ic_enders <- function(ssr, Tn, n_par) {
aic <- Tn * log(ssr) + 2 * n_par
bic <- Tn * log(ssr) + n_par * log(Tn)
list(AIC = aic, BIC = bic)
}
##----------------------------------------------------------
## 3. Construir datos para un modelo Dickey–Fuller con p lags
##
##    Δy_t    = dy_t
##    y_{t-1} = y_l1
##    regresión: dy_t ~ φ y_{t-1} + Σ γ_j Δy_{t-j}
##               sin intercepto
##----------------------------------------------------------
build_df_data <- function(y, p = 0) {
y  <- as.numeric(y)
Tn <- length(y)
dy   <- c(NA_real_, diff(y))
y_l1 <- c(NA_real_, y[-Tn])
dfm <- data.frame(dy = dy, y_l1 = y_l1)
if (p > 0) {
for (j in 1:p) {
dfm[[paste0("dy_l", j)]] <- c(rep(NA_real_, j), dy[1:(Tn - j)])
}
}
dfm <- dfm[complete.cases(dfm), , drop = FALSE]
if (nrow(dfm) < 20) stop("Insufficient observations after lagging.")
dfm
}
##----------------------------------------------------------
## 4. Estimar modelo Dickey–Fuller:
##    Δy_t = φ y_{t-1} + Σ γ_j Δy_{t-j} + ε_t
##----------------------------------------------------------
estimate_df_model <- function(y, p = 0) {
dfm <- build_df_data(y, p = p)
rhs <- c("y_l1")
if (p > 0) rhs <- c(rhs, paste0("dy_l", 1:p))
fml <- as.formula(paste("dy ~ 0 +", paste(rhs, collapse = " + ")))
mod <- lm(fml, data = dfm)
s   <- summary(mod)
# SSR, AIC, BIC
SSR   <- sum(resid(mod)^2)
Tn_m  <- nrow(dfm)
kU    <- length(coef(mod))
ic    <- ic_enders(SSR, Tn_m, kU)
coefs <- coef(s)
phi   <- coefs["y_l1", "Estimate"]
t_phi <- coefs["y_l1", "t value"]
# Ljung–Box Q(4) para residuales
Q4  <- Box.test(resid(mod), lag = 4, type = "Ljung-Box", fitdf = kU)
list(
model = mod,
p     = p,
phi   = phi,
t_phi = t_phi,
AIC   = ic$AIC,
BIC   = ic$BIC,
Q4    = as.numeric(Q4$statistic),
p_Q4  = Q4$p.value
)
}
##----------------------------------------------------------
## 5. Correr DF para p = 0 y p = 1
##----------------------------------------------------------
df_p0 <- estimate_df_model(y, p = 0)
df_p1 <- estimate_df_model(y, p = 1)
##----------------------------------------------------------
## 6. Resumen tipo tabla (para comparar con Enders & Granger)
##----------------------------------------------------------
df_results <- tibble(
model  = c("DF (p=0)", "DF (p=1)"),
phi    = c(df_p0$phi,    df_p1$phi),
t_phi  = c(df_p0$t_phi,  df_p1$t_phi),
AIC    = c(df_p0$AIC,    df_p1$AIC),
BIC    = c(df_p0$BIC,    df_p1$BIC),
Q4     = c(df_p0$Q4,     df_p1$Q4),
p_Q4   = c(df_p0$p_Q4,   df_p1$p_Q4)
)
print(df_results, digits = 4)
# Si quieres ver los coeficientes completos:
# summary(df_p0$model)
# summary(df_p1$model)
an <- anova(mod_eq, mod)
an
setwd("C:/Users/sergio.barona/Desktop/Least-cost-diets-and-affordability/Proyecto Interno/")
setwd("C:/Users/sergio.barona/Desktop/Least-cost-diets-and-affordability/Proyecto Interno/")
dataset <- read_excel(
"working-papers/working-paper-aecm/literature/enders_granger/dataset_enders.xlsx"
)
n_obs <- nrow(dataset)
dates_q <- seq.Date(
from = as.Date("1958-01-01"),
by   = "quarter",
length.out = n_obs
)
df <- dataset %>%
mutate(
date   = dates_q,
spread = r_10 - r_short
)
View(df)
reg_det <- lm(spread ~ 1, data = df)
y <- resid(reg_det)   # series used for TAR
Tn <- length(y)
y
build_tar_df <- function(y, p = 0) {
y <- as.numeric(y)
Tn <- length(y)
dy   <- c(NA, diff(y))
y_l1 <- c(NA, y[-Tn])
dy_l1 <- c(NA, diff(y_l1))
# TAR indicator: I_t = 1{ y_{t-1} < 0 }
I <- ifelse(dy_l1 < 0, 1, 0)
z1 <- I * y_l1
z2 <- (1 - I) * y_l1
dfm <- data.frame(dy = dy, z1 = z1, z2 = z2)
if (p > 0) {
for (j in 1:p) {
dfm[[paste0("dy_l", j)]] <- c(rep(NA, j), dy[1:(Tn - j)])
}
}
dfm <- dfm[complete.cases(dfm), , drop = FALSE]
if (nrow(dfm) < 20) stop("Insufficient observations after lagging.")
dfm
}
ic_enders <- function(ssr, Tn, n_par) {
aic <- Tn * log(ssr) + 2 * n_par
bic <- Tn * log(ssr) + n_par * log(Tn)
list(AIC = aic, BIC = bic)
}
df_results
View(df_results)
View(df_results)
