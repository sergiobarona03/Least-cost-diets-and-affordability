---
title: "Documento de trabajo 08/25: Primeras estimaciones"
author: "Sergio Barona Montoya"
date: '2025-07-14'
output:
  html_document:
    theme: cerulean
    highlight: tango
    toc: yes
    toc_float: yes
    number_sections: yes
    df_print: paged
  pdf_document:
    toc: yes
  word_document:
    toc: yes
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include = FALSE, echo=FALSE, eval = TRUE, warning=FALSE, message = FALSE}
library(janitor)
library(tidyverse)
```

# Presentación



# Datos

## Datos de precios minoristas - DANE

La primera fuente corresponde a los precios minoristas reportados por el DANE, utilizados como insumo para el cálculo del Índice de Precios al Consumidor (IPC) (DANE, 2024). El periodo de análisis abarca desde enero de 1999 hasta marzo de 2018 y cubre las 13 principales ciudades del país:

- Bogotá D.C.  
- Medellín A.M.  
- Cali A.M.  
- Barranquilla A.M.  
- Bucaramanga A.M.  
- Manizales A.M.  
- Pereira A.M.  
- Cúcuta A.M.  
- Pasto  
- Ibagué  
- Montería  
- Cartagena  
- Villavicencio  

Una característica relevante de estos datos es su estructura de clasificación, basada en la canasta de seguimiento del IPC 2008. Esta clasificación contempla distintos niveles de agregación: Grupo, Subgrupo, Clase, Gasto Básico y Artículo. A continuación, se presenta la estructura de esta clasificación:


```{r, include = TRUE, echo=FALSE, eval = TRUE, warning=FALSE, message = FALSE}
setwd("C:/Users/Portatil/Desktop/Least-cost-diets-and-affordability/Proyecto Interno")
ipc_subclase = readxl::read_excel("var-ipc/XYZ_Correlativa-ENPH-IPC-2008.xlsx") %>% janitor::clean_names() %>% mutate(clase = clase_9,
                                                                                                                      articulo = articulo_11) %>%
  select(clase, gasto_basico, articulo, descripcion_ipc)
head(ipc_subclase[11:nrow(ipc_subclase),], 30)
```

A continuación, se muestra la estructura de la base de datos de precios proporcionada por el DANE:

```{r, include = TRUE, echo=FALSE, eval = TRUE, warning=FALSE, message = FALSE}
setwd("C:/Users/Portatil/Desktop/Least-cost-diets-and-affordability/Proyecto Interno")
dane_99_18 = readxl::read_excel("Precios DANE\\OUTPUT_DANE\\precios_unadj_DANE_1999_2018.xlsx")

head(dane_99_18[c("ano", "mes_num", "nombre_ciudad", "codigo_articulo",
                  "articulo", "precio_500g")], 30)
```

## Datos del ÍPC - DANE

Para este análisis se emplean datos del Índice de Precios al Consumidor (IPC) a nivel de subclase, según lo reportado por el DANE. La clasificación utilizada corresponde al sistema COICOP, el cual estructura los datos en los siguientes niveles: División, Grupo, Clase, Subclase y Artículo.

Dado el objetivo de estimar precios minoristas, se hace uso exclusivamente del IPC a nivel de subclase. Además, se consideran únicamente los datos agregados por nivel de **ingreso total**.

A continuación, se muestra la estructura de los datos utilizados:

```{r, include = TRUE, echo=FALSE, eval = TRUE, warning=FALSE, message = FALSE}
setwd("C:/Users/Portatil/Desktop/Least-cost-diets-and-affordability/Proyecto Interno")
# Cargar variación del IPC
var_ipc = readxl::read_excel("var-ipc\\IPC.xls") %>% janitor::clean_names()

# Recodificar ciudades
var_ipc$ciudad[var_ipc$ciudad == "CARTAGENA DE INDIAS"] = "CARTAGENA"
var_ipc$ciudad[var_ipc$ciudad == "BOGOTÁ, D.C."] = "BOGOTÁ D.C."

# Crear variable codigo_subclase
var_ipc$cod_subclase = paste0(substr(var_ipc$subclase, 1, 8))
head(var_ipc[c("ano", "mes", "ciudad","division", "grupo", "clase", "subclase",
               "cod_subclase", "numero_indice")], 30)
```

# Metodología

## Conformación de la base de datos

Como se indicó en la sección anterior, las dos fuentes de información ---los precios minoristas y el IPC--- emplean sistemas de clasificación distintos. Mientras que los datos de precios minoristas utilizan la clasificación correspondiente a la canasta del IPC de 2008 (organizada por Grupo, Subgrupo, Clase, Gasto Básico y Artículo), los datos del IPC se encuentran estructurados según la nomenclatura COICOP (División, Grupo, Clase, Subclase, Artículo).

Para integrar ambos sistemas en una única base de datos, se recurre a la siguiente tabla correlativa:

```{r, include = TRUE, echo=FALSE, eval = TRUE, warning=FALSE, message = FALSE}
setwd("C:/Users/Portatil/Desktop/Least-cost-diets-and-affordability/Proyecto Interno")
#Tablas correlativas
correlativa = readxl::read_excel("var-ipc\\correlativa_ipc.xlsx")

# Llenar por celdas combinadas
correlativa <- correlativa %>%
    fill(subclase, ipc, .direction = "down") 

head(correlativa, 30)

```


## Análisis sobre el margen de comercialización

El margen de comercialización se estima comparando el precio minorista y el precio mayorista de cada producto, para cuantificar la diferencia relativa entre ambos.

Cualquiera que sea el producto $k$, el margen se define como:

$$
\text{Margen}_{k} = \frac{P^{\text{min}}_k - P^{\text{may}}_k}{P^{\text{may}}_k}
$$

donde $P_{k}^{min}$ corresponde al precio minorista y $P_{k}^{may}$ corresponde al precio mayorista del producto $k$. Para el análisis de los márgenes de comercialización, se examina su distribución a lo largo del tiempo. En particular, se calcula para cada producto el margen mediano (Q2) y los márgenes correspondientes al primer cuartil (Q1) y el tercer cuartil (Q3)

## Estimación de métricas basadas en dietas de costo mínimo

### CoCA - Costo mínimo de una dieta suficiente en energía

El CoCA se estima seleccionando el alimento —o conjunto de alimentos— que proporciona la cantidad de calorías necesaria para satisfacer el Requerimiento Energético Estimado (EER, por sus siglas en inglés).  
Siguiendo la literatura previa [3,9], para un grupo demográfico *i*, el CoCA se calcula mediante el siguiente modelo de programación lineal:

$$
\begin{aligned}
\text{Minimizar:} \quad & \sum_{j=1}^n p_j x_j \\
\text{sujeto a:} \quad & \sum_{j=1}^n e_j x_j = \text{EER}_i \\
& x_j \geq 0 \quad \forall j
\end{aligned}
$$

donde:

- \( x_j \) es la cantidad (en gramos) del alimento *j* seleccionada para un individuo del grupo *i*  
- \( p_j \) es el precio minorista del alimento *j*  
- \( e_j \) es el contenido energético (en kcal/gramo) del alimento *j*  
- \( \text{EER}_i \) es el Requerimiento Energético Estimado para un individuo del grupo demográfico *i*  

La solución óptima de este modelo corresponde a construir una dieta compuesta por el alimento con menor precio por kilocaloría. 

### CoNA – Costo mínimo de una dieta adecuada en nutrientes.

El CoNA se determina a partir del conjunto de alimentos disponibles que, para una ubicación y período de estudio determinados, permiten satisfacer el (EER) al menor costo posible, cumpliendo además con los límites inferior y superior de ingesta de macro- y micronutrientes. Para un grupo demográfico \( i \), la métrica CoNA se obtiene resolviendo el siguiente modelo de programación lineal:

\[
\text{CoNA}(i) = \min_{x_1, \dots, x_n} \sum_{j=1}^n p_j x_j
\]

sujeto a:

\[
\sum_{j=1}^n e_j x_j = \text{EER}_i
\]

\[
\sum_{j=1}^n a_{kj} x_j \leq U_{ik} \quad \forall k
\]

\[
\sum_{j=1}^n a_{kj} x_j \geq L_{ik} \quad \forall k
\]

\[
x_j \geq 0
\]

Donde:

- \( x_j \) es la cantidad —en gramos— del alimento \( j \) en la dieta óptima.
- \( p_j \) corresponde al precio minorista del alimento \( j \).
- \( e_j \) es el contenido energético (kcal) por gramo del alimento \( j \).
- \( a_{kj} \) indica el contenido del nutriente \( k \) en el alimento \( j \).
- \( L_{ik} \) y \( U_{ik} \) son, respectivamente, los límites inferior y superior de ingesta para el nutriente \( k \) en el grupo demográfico \( i \).

# Resultados

## Margen de comercialización estimados

```{r, include = TRUE, echo=FALSE, eval = TRUE, warning=FALSE, message = FALSE}

########################################################
## Prueba: estimación según variación mensual del IPC ##
## Fecha: 22 de junio de 2025                         ##
########################################################

# Cargar librerías
library(lubridate)
library(tidyverse)

# Definir directorio de trabajo
setwd("C:\\Users\\Portatil\\Desktop\\Least-cost-diets-and-affordability\\Proyecto Interno\\")

# Cargar datos
source("margen-dist/v1-join-ipc-sipsa.R")

######################################
###--------------------------------###
### Datos sobre precios minoristas ###
###--------------------------------###
######################################

# Filtro para Cali, Medellín y Bogotá
whole_tres = retail_whole_18 %>% filter(nombre_ciudad %in% c("MEDELLÍN",
                                                             "CALI",
                                                             "BOGOTÁ D.C.")) %>%
  rename(precio_500g_ipc = precio_500g,
         precio_500g_sipsa = precio_medio)

# Organizar la base de datos
data_min_may = whole_tres %>% select(cod_mun ,ciudad, nombre_ciudad,
                                     Year,
                                     mes, Month, Alimento, retail,
                                     codigo_articulo, precio_500g_sipsa,
                                     precio_500g_ipc) %>%
  rename(mes_num = Month,
         ano = Year,
         sipsa = Alimento,
         articulo = retail)

# Recodificar fecha
data_min_may$fecha = as.Date(paste(data_min_may$ano, 
                                   data_min_may$mes_num, 
                                "01", sep = "-"))

# Filtrar para la ciudad principal
ciudad.input = c("CALI")
data_min_may = data_min_may %>% filter(nombre_ciudad %in% ciudad.input)

# Condición de exclusión:
food.exclude = vector(mode = "list")
foods_no_exclude = levels(as.factor(as.character(data_min_may$sipsa)))

# Función para definir la exclusión
tiene_48 <- function(serie_mat) {
  
  serie_vec <- as.vector(t(serie_mat))
  no_na <- !is.na(serie_vec)
  max_consecutivos <- rle(no_na)$lengths[which(rle(no_na)$values)]
  any(max_consecutivos >= 36)
  
}

for (k in 1:length(foods_no_exclude)) {
  data_k = data_min_may %>% filter(sipsa == foods_no_exclude[[k]])
  
  start1 = min(data_k$fecha)
  end1 = max(data_k$fecha)
  
  series_sipsa = ts(data_k$precio_500g_sipsa, 
                    start = c(substr(start1, 1, 4), substr(start1, 6, 7)), 
                    end = c(substr(end1, 1, 4), substr(end1, 6, 7))
                    , frequency = 12)
  
  series_ipc = ts(data_k$precio_500g_ipc, 
                  start = c(substr(start1, 1, 4), substr(start1, 6, 7)), 
                  end = c(substr(end1, 1, 4), substr(end1, 6, 7))
                  , frequency = 12)
  
  if(!(tiene_48(series_sipsa) & tiene_48(series_ipc))){
    food.exclude = append(food.exclude, unique(data_k$sipsa))
  }
  
}

# Excluimos los alimentos que no cumplen la condición
data_min_may = data_min_may %>% filter(!sipsa %in% unlist(food.exclude))

# Crear la variable "código subclase"
data_min_may$cod_subclase = paste0("0",substr(data_min_may$codigo_articulo, 1, 6), "0")

# Calcular los cuartiles por subclase
margen_articulo <- data_min_may %>% 
  group_by(articulo) %>%
  mutate(
    factor = precio_500g_ipc / precio_500g_sipsa,
    margen = (factor - 1) * 100
  ) %>% filter(margen > 0)

# Examinar la distribución para cada uno
library(ggplot2)
library(viridis)

# Lista de subclases únicas
subclases <- unique(margen_articulo$cod_subclase)

# Bucle para graficar cada subclase
for (sc in subclases) {
  
  # Filtrar datos para la subclase actual
  df_sub <- subset(margen_articulo, cod_subclase == sc)
  
  # Crear gráfico
  p <- ggplot(df_sub, aes(x = articulo, y = margen, fill = articulo)) +
    geom_boxplot(outlier.colour = "red", outlier.shape = 16, outlier.size = 2, alpha = 0.7) +
    scale_fill_viridis_d(option = "plasma", guide = "none") +
    theme_bw(base_size = 14) +
    theme(
      panel.grid.major.y = element_line(color = "gray90"),
      panel.grid.minor = element_blank(),
      strip.background = element_rect(fill = "gray85", color = NA),
      axis.text.x = element_text(angle = 45, hjust = 1)
    ) +
    labs(
      x = "Artículo",
      y = "Margen",
      title = paste("Distribución de márgenes - Subclase", sc)
    )
  
  print(p)

}

```

## Precios a partir de los márgenes de comercialización

```{r, include = TRUE, echo=FALSE, eval = TRUE, warning=FALSE, message = FALSE}

########################################################
## Prueba: estimación según variación mensual del IPC ##
## Fecha: 22 de junio de 2025                         ##
########################################################

# Cargar librerías
library(lubridate)
library(tidyverse)
library(FoodpriceR)

# Definir directorio de trabajo
setwd("C:\\Users\\Portatil\\Desktop\\Least-cost-diets-and-affordability\\Proyecto Interno\\")

# Cargar datos de márgenes
source("margen-dist/v2-margen-producto.R")

```


## Estimación de métricas

### Estimación CoCA

```{r, include = TRUE, echo=FALSE, eval = TRUE, warning=FALSE, message = FALSE}

# Definir directorio de trabajo
setwd("C:\\Users\\Portatil\\Desktop\\Least-cost-diets-and-affordability\\Proyecto Interno\\")

# Cargar Estimaciones CoCA
source("estimadores-banrep\\CALI\\coca\\v1_coca_q1_q3.R")


```

### Estimación CoNA

```{r, include = TRUE, echo=FALSE, eval = TRUE, warning=FALSE, message = FALSE}

# Definir directorio de trabajo
setwd("C:\\Users\\Portatil\\Desktop\\Least-cost-diets-and-affordability\\Proyecto Interno\\")

# Cargar Estimaciones CoCA
source("estimadores-banrep\\CALI\\cona\\v1_cona_q1_q3.R")


```


# Referencias




