---
title: "IPC – Exploración, Regresión y Pruebas de Estacionalidad"
author: "Daniela Valdés Cárdenas"
date: "2025-09-05"
output:
  html_document:
    theme: cerulean
    highlight: tango
    toc: true
    toc_float: true
    number_sections: true
    df_print: paged
    code_folding: show
  pdf_document:
    toc: true
  word_document:
    toc: true
params:
  ciudad_objetivo: "CALI"
  fecha_tope: !r as.Date("2018-03-01")
  anio_base: 2018
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
```

```{r}
library(readxl)
library(dplyr)
library(tidyr)
library(janitor)
library(purrr)
library(broom)
library(stringr)
library(tibble)
library(ggplot2)
```

# Exploración de datos

En esta sección cargamos datos, definimos funciones de estandarización de códigos y evidenciamos por qué no todas las subclases del IPC aparecen para la ciudad objetivo. La idea es dejar una traza clara: qué hay en cada fuente y qué se cruza con qué.

## Carga de librerías y funciones auxiliares

Cargamos paquetes y declaramos normalizadores. Usamos dos representaciones de subclase:

-   subclase (8 dígitos) de la correlativa ENPH–IPC (formato “0 + 6 + 0”, p. ej. 01510100).

-   sub6 (6 dígitos) como clave de unión con el IPC mensual (p. ej. 151010). La conversión 8→6 dígitos evita pérdidas por formato en el join.

```{r}

# Normalizadores (fuerzan character y evitan lógicos)
norm_subclase_compat <- function(x){
  dig <- gsub("[^0-9]","",as.character(x))
  n <- nchar(dig)
  out <- ifelse(n == 6, paste0("0",dig,"0"),
         ifelse(n >= 8, substr(dig,1,8),
         ifelse(n == 7, paste0("0",dig),
                stringr::str_pad(dig,8,side="right",pad="0"))))
  as.character(out)
}
subclase_to6 <- function(x){
  dig <- gsub("[^0-9]","",as.character(x))
  n <- nchar(dig)
  out <- ifelse(n >= 8, substr(dig,2,7),
         ifelse(n == 6, dig,
         ifelse(n == 7, substr(dig,1,6),
                stringr::str_pad(dig,6,pad="0"))))
  as.character(out)
}
norm_articulo7 <- function(x){ as.character(gsub("[^0-9]","",as.character(x))) }

# Normalización a 8 dígitos 
norm_sub8 <- function(x) substr(gsub("[^0-9]", "", as.character(x)), 1, 8)

```

## Cargar correlativa, precios e IPC

```{r}

ipc_union_path <- "C:/Users/danie/OneDrive/Escritorio/Least-cost-diets-and-affordability/Proyecto Interno/var-ipc/output_final_union_ipc.xlsx"

# Meses (por si el archivo trae el mes como texto)
meses_esp <- c("Ene","Feb","Mar","Abr","May","Jun","Jul","Ago","Sep","Oct","Nov","Dic")

# Helper para elegir columna por nombre alternativo
pick_col <- function(df, opts, label){
  nm <- names(df); hit <- opts[opts %in% nm]
  if (!length(hit)) stop("No encontré columna ", label, ". Tengo: ", paste(nm, collapse=", "))
  hit[1]
}

ipc_union_raw <- readxl::read_excel(ipc_union_path) %>% janitor::clean_names()

col_ciudad   <- pick_col(ipc_union_raw, c("nombre_ciudad","ciudad"), "ciudad")
col_sub8     <- pick_col(ipc_union_raw, c("cod_subclase","subclase"), "cod_subclase/subclase")
col_ano      <- pick_col(ipc_union_raw, c("ano","year"), "ano")
col_mes      <- pick_col(ipc_union_raw, c("mes_num","mes"), "mes/mes_num")
col_ipc      <- pick_col(ipc_union_raw, c("ipc","numero_indice"), "ipc/numero_indice")
col_codart   <- pick_col(ipc_union_raw, c("codigo_articulo","cod_articulo","articulo"), "codigo_articulo")
col_precios  <- pick_col(ipc_union_raw, c("precio_500g","precio"), "precio_500g/precio")
col_nombre_a <- pick_col(ipc_union_raw, c("articulo","nombre_articulo","nombre_producto"), "articulo (nombre)")

ipc_data <- ipc_union_raw %>%
  transmute(
    ciudad = dplyr::recode(.data[[col_ciudad]],
                           "CARTAGENA DE INDIAS" = "CARTAGENA",
                           "BOGOTÁ, D.C."        = "BOGOTÁ D.C.",
                           "BOGOTC, D.C."        = "BOGOTÁ D.C.",
                           "BOGOTC\u0001, D.C."  = "BOGOTÁ D.C."),
    cod_subclase   = norm_sub8(.data[[col_sub8]]),
    ano            = as.numeric(.data[[col_ano]]),
    mes_num        = dplyr::case_when(
                       suppressWarnings(!any(is.na(as.integer(.data[[col_mes]])))) ~ as.integer(.data[[col_mes]]),
                       TRUE ~ match(as.character(.data[[col_mes]]), meses_esp)
                     ),
    ipc            = as.numeric(.data[[col_ipc]]),
    codigo_articulo= norm_articulo7(.data[[col_codart]]),
    articulo       = as.character(.data[[col_nombre_a]]),
    precio         = as.numeric(.data[[col_precios]])
  ) %>%
  filter(ciudad == params$ciudad_objetivo) %>%
  mutate(fecha = as.Date(sprintf("%d-%02d-01", ano, mes_num))) %>%
  filter(fecha <= params$fecha_tope)

```

## Catálogo y selección de subclases objetivo (frutas frescas)

```{r}
## === Frutas frescas  ===
fruta_sub8 <- c("01410500")

# === Filtrar frutas y construir variables para la regresión ===
dat_fruta <- ipc_data %>%
  mutate(cod8 = norm_sub8(cod_subclase)) %>%
  filter(cod8 %in% fruta_sub8) %>%
  mutate(
    sub6  = substr(cod8, 2, 7),   
    lnIPC = log(ipc)
  ) %>%
  select(-cod8)

stopifnot(nrow(dat_fruta) > 0)

# === Precio base P0 por artículo en el año base + fallback al primer precio ===
p0_tabla <- dat_fruta %>%
  filter(ano == params$anio_base) %>%
  group_by(codigo_articulo) %>%
  summarise(p0 = mean(precio, na.rm = TRUE), .groups = "drop")

p0_fb <- dat_fruta %>%
  arrange(codigo_articulo, fecha) %>%
  group_by(codigo_articulo) %>%
  summarise(p0_fb = dplyr::first(na.omit(precio)), .groups = "drop")

p0_tabla <- full_join(p0_tabla, p0_fb, by = "codigo_articulo") %>%
  mutate(p0 = dplyr::coalesce(p0, p0_fb)) %>%
  select(codigo_articulo, p0)

# === Panel final para la regresión ===
panel_reg <- dat_fruta %>%
  left_join(p0_tabla, by = "codigo_articulo") %>%
  filter(!is.na(precio), !is.na(p0), p0 > 0) %>%
  mutate(
    ln_rel   = log(precio) - log(p0),
    subclase = cod_subclase   # etiqueta con sub8
  ) %>%
  select(subclase, sub6, fecha, articulo, lnIPC, ln_rel)

stopifnot(nrow(panel_reg) > 0)
cat("✔️ Filas panel_reg (frutas): ", nrow(panel_reg), "\n")
```

# Modelo de regresión lineal (log–log)

La especificación es:

$$
\log(IPC_t)\;=\;\alpha_0\;+\;\sum_{j=1}^{n}\beta_j\,\log\!\left(\frac{P_{jt}}{P_{j0}}\right)\;+\;\varepsilon_t .
$$

donde:

$$
\log\!\left(\frac{P_{jt}}{P_{j0}}\right)\;\equiv\;\text{ln_rel}_{jt}.
$$

Estimamos por subclase (cada subclase tiene su combinación de artículos).

## Estimación por subclase (sólo frutas frescas)

```{r}
library(broom)

lm_dyn <- purrr::possibly(function(d) {
  d_wide <- tidyr::pivot_wider(
    d, names_from = articulo, values_from = ln_rel, names_prefix = "ln_rel_"
  )
  xvars <- grep("^ln_rel_", names(d_wide), value = TRUE)
  if (!length(xvars)) return(tibble())
  na_all <- vapply(d_wide[xvars], function(v) all(is.na(v)), logical(1))
  xkeep  <- xvars[!na_all]
  if (!length(xkeep)) return(tibble())
  fit <- lm(lnIPC ~ ., data = d_wide[, c("lnIPC", xkeep), drop = FALSE],
            na.action = na.exclude)
  broom::tidy(fit) %>% filter(term != "(Intercept)", !is.na(estimate)) %>%
    mutate(term = as.character(term))
}, otherwise = tibble())

glance_dyn <- purrr::possibly(function(d) {
  d_wide <- tidyr::pivot_wider(
    d, names_from = articulo, values_from = ln_rel, names_prefix = "ln_rel_"
  )
  xvars <- grep("^ln_rel_", names(d_wide), value = TRUE)
  if (!length(xvars)) return(tibble())
  na_all <- vapply(d_wide[xvars], function(v) all(is.na(v)), logical(1))
  xkeep  <- xvars[!na_all]
  if (!length(xkeep)) return(tibble())
  fit <- lm(lnIPC ~ ., data = d_wide[, c("lnIPC", xkeep), drop = FALSE],
            na.action = na.exclude)
  broom::glance(fit) %>% mutate(n_regresores = length(xkeep))
}, otherwise = tibble())

res_coef <- panel_reg %>%
  group_by(subclase) %>%
  group_modify(~ lm_dyn(.x)) %>%
  ungroup() %>%
  mutate(alimento = sub("^ln_rel_", "", term)) %>%
  select(subclase, alimento, estimate, std.error, statistic, p.value)

res_modelo <- panel_reg %>%
  group_by(subclase) %>%
  group_modify(~ glance_dyn(.x)) %>%
  ungroup()

# Vistas
head(res_coef, 20)
res_modelo %>% arrange(desc(adj.r.squared)) %>% head(10)

```

# Pruebas de estacionalidad y tendencia

```{r}
# install.packages(c("tseries","urca","seastests"))
library(tseries)
library(urca)
library(seastests)
```

```{r}
# install.packages(c("tseries","urca","seastests"))
library(tseries)
library(urca)
library(seastests)

series_lnIPC <- panel_reg %>%
  distinct(subclase, fecha, lnIPC) %>%
  arrange(subclase, fecha) %>%
  group_by(subclase) %>%
  summarise(
    fecha_min = min(fecha), fecha_max = max(fecha),
    n = n(), .groups = "drop"
  )

testear_subclase <- function(sub_id){
  df <- panel_reg %>% filter(subclase == sub_id) %>% arrange(fecha) %>%
    distinct(fecha, lnIPC)
  start_year  <- as.numeric(format(min(df$fecha), "%Y"))
  start_month <- as.numeric(format(min(df$fecha), "%m"))
  ts_ln <- ts(df$lnIPC, start = c(start_year, start_month), frequency = 12)

  adf_p <- tryCatch(tseries::adf.test(na.omit(ts_ln), alternative = "stationary")$p.value,
                    error = function(e) NA_real_)
  kpss_p <- tryCatch(tseries::kpss.test(na.omit(ts_ln), null = "Level")$p.value,
                     error = function(e) NA_real_)
  seas_flag <- tryCatch(seastests::isSeasonal(na.omit(ts_ln), test = "wo"),
                        error = function(e) NA)

  tibble(subclase = sub_id, adf_p = adf_p, kpss_p = kpss_p, estacional = seas_flag)
}

res_tests <- panel_reg %>%
  distinct(subclase) %>%
  pull(subclase) %>%
  purrr::map_dfr(testear_subclase) %>%
  mutate(
    clasificacion = dplyr::case_when(
      !is.na(adf_p)  & adf_p < 0.05 & !is.na(kpss_p) & kpss_p > 0.1 ~ "Estacionaria (ADF rechaza RU, KPSS no rechaza)",
      !is.na(adf_p)  & adf_p >= 0.05 & !is.na(kpss_p) & kpss_p < 0.1 ~ "No estacionaria (posible RU)",
      TRUE ~ "Indefinida / revisar"
    )
  )

res_tests %>% count(clasificacion)
res_tests %>% count(estacional)
head(res_tests, 15)

```
