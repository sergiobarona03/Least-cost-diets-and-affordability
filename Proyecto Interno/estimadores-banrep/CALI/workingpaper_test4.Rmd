---
title: "IPC – Exploración, Regresión y Pruebas de Estacionalidad"
author: "Daniela Valdés Cárdenas"
date: "2025-08-24"
output:
  html_document:
    theme: cerulean
    highlight: tango
    toc: true
    toc_float: true
    number_sections: true
    df_print: paged
    code_folding: show
  pdf_document:
    toc: true
  word_document:
    toc: true
params:
  ciudad_objetivo: "CALI"
  fecha_tope: !r as.Date("2018-03-01")
  anio_base: 2008
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
```

```{r}
library(readxl)
library(dplyr)
library(tidyr)
library(janitor)
library(purrr)
library(broom)
library(stringr)
library(tibble)
library(ggplot2)
```

# Exploración de datos

En esta sección cargamos datos, definimos funciones de estandarización de códigos y evidenciamos por qué no todas las subclases del IPC aparecen para la ciudad objetivo. La idea es dejar una traza clara: qué hay en cada fuente y qué se cruza con qué.

## Carga de librerías y funciones auxiliares

Cargamos paquetes y declaramos normalizadores. Usamos dos representaciones de subclase:

-   subclase (8 dígitos) de la correlativa ENPH–IPC (formato “0 + 6 + 0”, p. ej. 01510100).

-   sub6 (6 dígitos) como clave de unión con el IPC mensual (p. ej. 151010). La conversión 8→6 dígitos evita pérdidas por formato en el join.

```{r}

# Normalizadores (fuerzan character y evitan lógicos)
norm_subclase_compat <- function(x){
  dig <- gsub("[^0-9]","",as.character(x))
  n <- nchar(dig)
  out <- ifelse(n == 6, paste0("0",dig,"0"),
         ifelse(n >= 8, substr(dig,1,8),
         ifelse(n == 7, paste0("0",dig),
                stringr::str_pad(dig,8,side="right",pad="0"))))
  as.character(out)
}
subclase_to6 <- function(x){
  dig <- gsub("[^0-9]","",as.character(x))
  n <- nchar(dig)
  out <- ifelse(n >= 8, substr(dig,2,7),
         ifelse(n == 6, dig,
         ifelse(n == 7, substr(dig,1,6),
                stringr::str_pad(dig,6,pad="0"))))
  as.character(out)
}
norm_articulo <- function(x){ as.character(gsub("[^0-9]","",as.character(x))) }

leer_ipc_sheet <- function(path, sheet, ciudad, fecha_tope){
  df <- suppressMessages(readxl::read_excel(path, sheet = sheet)) %>% clean_names()
  req <- c("ciudad","ano","mes","subclase","numero_indice")
  if (!all(req %in% names(df))) return(NULL)
  df %>%
    mutate(
      ciudad = recode(ciudad,
        "CARTAGENA DE INDIAS"="CARTAGENA",
        "BOGOTÁ, D.C."="BOGOTÁ D.C."
      ),
      mes_num = recode(mes,
        "Ene"=1,"Feb"=2,"Mar"=3,"Abr"=4,"May"=5,"Jun"=6,
        "Jul"=7,"Ago"=8,"Sep"=9,"Oct"=10,"Nov"=11,"Dic"=12),
      fecha = as.Date(sprintf("%d-%02d-01", as.integer(ano), mes_num)),
      sub8  = norm_subclase_compat(subclase),
      sub6  = subclase_to6(sub8),
      lnIPC = log(as.numeric(numero_indice))
    ) %>%
    filter(ciudad == params$ciudad_objetivo, fecha <= params$fecha_tope) %>%
    distinct(fecha, sub6, lnIPC, .keep_all = TRUE)
}
```

## Cargar correlativa, precios e IPC

```{r}
# ===== RUTAS ABSOLUTAS =====
ruta_correlativa <- "C:/Users/danie/OneDrive/Escritorio/Least-cost-diets-and-affordability/Proyecto Interno/var-ipc/XYZ_Correlativa-ENPH-IPC-2008.xlsx"
ruta_precios     <- "C:/Users/danie/OneDrive/Escritorio/Least-cost-diets-and-affordability/Proyecto Interno/Precios DANE/OUTPUT_DANE/precios_unadj_DANE_1999_2018.xlsx"
ruta_ipc         <- "C:/Users/danie/OneDrive/Escritorio/Least-cost-diets-and-affordability/Proyecto Interno/var-ipc/IPC.xls"

stopifnot(file.exists(ruta_correlativa), file.exists(ruta_precios), file.exists(ruta_ipc))

# ---------- 1) Correlativa (con FILL DOWN y autodetección de columnas) ----------

ipc_raw <- readxl::read_excel(ruta_correlativa) %>%
  janitor::clean_names()

# 1a) RELLENAR HACIA ABAJO (todas las columnas)
ipc_filled <- ipc_raw %>%
  mutate(across(everything(), ~na_if(., ""))) %>%   # trata "" como NA
  tidyr::fill(everything(), .direction = "down")

cat("➡️ Columnas (correlativa) tras clean_names():\n"); print(names(ipc_filled))

# 1b) SUBCLASE (lado COICOP) -> sub8/sub6
stopifnot("subclase" %in% names(ipc_filled))
sub8_vec <- norm_subclase_compat(ipc_filled$subclase)
sub6_vec <- subclase_to6(sub8_vec)

# 1c) ELEGIR AUTOMÁTICAMENTE LA COLUMNA DE ARTÍCULO DEL IPC-2008 (7 dígitos)
cand_art <- grep("^articulo", names(ipc_filled), value = TRUE)
stopifnot(length(cand_art) >= 1)

# Heurística: elegir la columna con MÁS valores que lucen de 7 dígitos
score_col <- function(colname){
  v7 <- norm_articulo7(ipc_filled[[colname]])
  sum(!is.na(v7) & nchar(v7) == 7)
}
art_scores <- sapply(cand_art, score_col)
col_art_right <- cand_art[ which.max(art_scores) ]

cat("✔️ Columna ARTÍCULO elegida:", col_art_right,
    " (candidatas =", paste(cand_art, collapse=", "), ")\n")

articulo_ipc7 <- norm_articulo7(ipc_filled[[col_art_right]])

# 1d) Descripciones (OPCIONALES, con fill ya aplicado)
desc_ipc  <- if ("descripcion_ipc"    %in% names(ipc_filled)) as.character(ipc_filled$descripcion_ipc)    else NA_character_
desc_coic <- if ("descripcion_coicop" %in% names(ipc_filled)) as.character(ipc_filled$descripcion_coicop) else NA_character_
gasto_bas <- if ("gasto_basico"       %in% names(ipc_filled)) as.character(ipc_filled$gasto_basico)       else NA_character_

# 1e) Tabla correlativa lista para mapear ARTÍCULO(7d) -> sub6/sub8
ipc_subclase <- tibble(
  sub8 = sub8_vec,
  sub6 = sub6_vec,
  articulo = articulo_ipc7,
  descripcion_ipc = dplyr::coalesce(desc_ipc, desc_coic),
  gasto_basico    = gasto_bas
) %>%
  filter(!is.na(sub6), sub6 != "", !is.na(articulo), articulo != "")

# 1f) Mapeo único artículo → sub6/sub8
mapeo_unico <- ipc_subclase %>%
  arrange(articulo) %>% group_by(articulo) %>% slice(1) %>% ungroup()

# 1g) Diagnóstico rápido
cat("✔️ nchar artículo (correlativa):", paste(sort(unique(nchar(mapeo_unico$articulo))), collapse=", "), "\n")
cat("✔️ Subclases frutas frescas presentes (prefijo sub8=011609): ",
    sum(substr(ipc_subclase$sub8,1,6)=="011609"), "\n")

# ---------- 2) PRECIOS (asegurar 7 dígitos) ----------
raw_precios <- readxl::read_excel(ruta_precios) %>% janitor::clean_names()
stopifnot(all(c("ano","mes_num","nombre_ciudad","codigo_articulo","precio_500g") %in% names(raw_precios)))

# misma normalización de 7 dígitos que usamos en la correlativa
precios <- raw_precios %>%
  transmute(
    anio       = as.integer(ano),
    mes        = as.integer(mes_num),
    ciudad     = as.character(nombre_ciudad),
    articulo   = norm_articulo7(codigo_articulo),
    nombre_art = as.character(articulo),
    precio     = as.numeric(precio_500g),
    fecha      = as.Date(sprintf("%d-%02d-01", anio, mes))
  ) %>%
  filter(ciudad == params$ciudad_objetivo, fecha <= params$fecha_tope)

cat("✔️ Filas precios filtrados:", nrow(precios), 
    " | nchar(artículo) únicos:", paste(unique(nchar(precios$articulo)), collapse=", "), "\n")

# ---------- 3) IPC mensual (var_ipc6) ----------
sheets_ipc <- readxl::excel_sheets(ruta_ipc)
leer_all <- function(sh) suppressMessages(leer_ipc_sheet(ruta_ipc, sh, params$ciudad_objetivo, params$fecha_tope))
scan_ipc <- purrr::map_dfr(sheets_ipc, function(sh){
  out <- leer_all(sh)
  if (is.null(out)) tibble(sheet=sh, ok=FALSE, n_sub6=NA_integer_)
  else tibble(sheet=sh, ok=TRUE, n_sub6=dplyr::n_distinct(out$sub6))
})
best_sheet <- scan_ipc %>% dplyr::filter(ok) %>% dplyr::arrange(dplyr::desc(n_sub6)) %>% dplyr::slice(1) %>% dplyr::pull(sheet)
cat("✔️ Hoja IPC elegida:", best_sheet, "\n")

var_ipc6 <- leer_all(best_sheet) %>% dplyr::transmute(fecha, sub6 = as.character(sub6), lnIPC)
cat("✔️ Filas var_ipc6:", nrow(var_ipc6), "\n")

# ---------- 4) JOIN precios + correlativa ⇒ df_retail ----------
df_retail <- precios %>%
  dplyr::left_join(mapeo_unico, by = "articulo") %>%
  dplyr::filter(!is.na(sub6), sub6 != "")

cat("✔️ Filas df_retail (con sub6):", nrow(df_retail), "\n")

# (Diagnóstico rápido si algo sale vacío)
if (nrow(df_retail) == 0) {
  inter <- intersect(precios$articulo, mapeo_unico$articulo)
  cat("⚠️ Intersección de artículos (precios vs correlativa):", length(inter), "\n")
  cat("Ejemplos precios:", head(unique(precios$articulo), 10), "\n")
  cat("Ejemplos correlativa:", head(unique(mapeo_unico$articulo), 10), "\n")
}


```

## Catálogo y selección de subclases objetivo (frutas frescas)

```{r}
# =======================
# DETECCIÓN AUTOMÁTICA DE FRUTAS EN LA CORRELATIVA
# =======================

# ---------- 4) FILTRO: SOLO FRUTAS FRESCAS ----------
# Clase COICOP = 011609 ⇒ sub8 empieza por "011609"
# Como ya tenemos sub6, usar sub8 del mapeo para rótulo y control
catalogo_desc <- ipc_subclase %>% distinct(sub6, .keep_all = TRUE)

sub6_objetivo <- catalogo_desc %>%
  filter(substr(sub8, 1, 6) == "011609") %>%   # <— clave
  distinct(sub6)

if (nrow(sub6_objetivo) == 0) {
  stop("No encontré subclases de 'Frutas frescas' (prefijo sub8=011609) en la correlativa.")
}

# ---------- 5) PANEL restringido a frutas frescas ----------
panel0 <- df_retail %>%
  inner_join(var_ipc6, by = c("fecha","sub6")) %>%
  semi_join(sub6_objetivo, by = "sub6")

# Precio base P0 (año base) + fallback
p0_tabla <- df_retail %>%
  filter(anio == params$anio_base) %>%
  group_by(articulo) %>% summarise(p0 = mean(precio, na.rm = TRUE), .groups = "drop")

p0_fb <- df_retail %>%
  arrange(articulo, fecha) %>%
  group_by(articulo) %>% summarise(p0_fb = first(na.omit(precio)), .groups = "drop")

p0_tabla <- full_join(p0_tabla, p0_fb, by = "articulo") %>%
  mutate(p0 = if_else(is.na(p0), p0_fb, p0)) %>%
  select(articulo, p0)

# Rótulo de subclase (sub8) para la regresión
art_sub8 <- mapeo_unico %>% distinct(articulo, sub8)

panel_reg <- panel0 %>%
  left_join(p0_tabla, by = "articulo") %>%
  left_join(art_sub8, by = "articulo") %>%
  filter(!is.na(precio), !is.na(p0)) %>%
  mutate(
    ln_rel   = log(precio) - log(p0),
    subclase = sub8
  ) %>%
  select(subclase, sub6, fecha, articulo, lnIPC, ln_rel)

stopifnot(nrow(panel_reg) > 0, all(substr(panel_reg$subclase,1,6)=="011609"))
cat("Filas panel_reg (solo frutas frescas):", nrow(panel_reg), "\n")
```

# Modelo de regresión lineal (log–log)

La especificación es:

$$
\log(IPC_t)\;=\;\alpha_0\;+\;\sum_{j=1}^{n}\beta_j\,\log\!\left(\frac{P_{jt}}{P_{j0}}\right)\;+\;\varepsilon_t .
$$

donde:

$$
\log\!\left(\frac{P_{jt}}{P_{j0}}\right)\;\equiv\;\text{ln_rel}_{jt}.
$$

Estimamos por subclase (cada subclase tiene su combinación de artículos).

## Estimación por subclase (sólo frutas frescas)

```{r}
library(broom)

lm_dyn <- purrr::possibly(function(d) {
  d_wide <- tidyr::pivot_wider(
    d, names_from = articulo, values_from = ln_rel, names_prefix = "ln_rel_"
  )
  xvars <- grep("^ln_rel_", names(d_wide), value = TRUE)
  if (!length(xvars)) return(tibble())
  na_all <- vapply(d_wide[xvars], function(v) all(is.na(v)), logical(1))
  xkeep  <- xvars[!na_all]
  if (!length(xkeep)) return(tibble())
  fit <- lm(lnIPC ~ ., data = d_wide[, c("lnIPC", xkeep), drop = FALSE],
            na.action = na.exclude)
  broom::tidy(fit) %>% filter(term != "(Intercept)", !is.na(estimate)) %>%
    mutate(term = as.character(term))
}, otherwise = tibble())

glance_dyn <- purrr::possibly(function(d) {
  d_wide <- tidyr::pivot_wider(
    d, names_from = articulo, values_from = ln_rel, names_prefix = "ln_rel_"
  )
  xvars <- grep("^ln_rel_", names(d_wide), value = TRUE)
  if (!length(xvars)) return(tibble())
  na_all <- vapply(d_wide[xvars], function(v) all(is.na(v)), logical(1))
  xkeep  <- xvars[!na_all]
  if (!length(xkeep)) return(tibble())
  fit <- lm(lnIPC ~ ., data = d_wide[, c("lnIPC", xkeep), drop = FALSE],
            na.action = na.exclude)
  broom::glance(fit) %>% mutate(n_regresores = length(xkeep))
}, otherwise = tibble())

res_coef <- panel_reg %>%
  group_by(subclase) %>%
  group_modify(~ lm_dyn(.x)) %>%
  ungroup() %>%
  mutate(alimento = sub("^ln_rel_", "", term)) %>%
  select(subclase, alimento, estimate, std.error, statistic, p.value)

res_modelo <- panel_reg %>%
  group_by(subclase) %>%
  group_modify(~ glance_dyn(.x)) %>%
  ungroup()

# Vistas
head(res_coef, 20)
res_modelo %>% arrange(desc(adj.r.squared)) %>% head(10)

```

# Pruebas de estacionalidad y tendencia

```{r}
# install.packages(c("tseries","urca","seastests"))
library(tseries)
library(urca)
library(seastests)
```

```{r}
# install.packages(c("tseries","urca","seastests"))
library(tseries)
library(urca)
library(seastests)

series_lnIPC <- panel_reg %>%
  distinct(subclase, fecha, lnIPC) %>%
  arrange(subclase, fecha) %>%
  group_by(subclase) %>%
  summarise(
    fecha_min = min(fecha), fecha_max = max(fecha),
    n = n(), .groups = "drop"
  )

testear_subclase <- function(sub_id){
  df <- panel_reg %>% filter(subclase == sub_id) %>% arrange(fecha) %>%
    distinct(fecha, lnIPC)
  start_year  <- as.numeric(format(min(df$fecha), "%Y"))
  start_month <- as.numeric(format(min(df$fecha), "%m"))
  ts_ln <- ts(df$lnIPC, start = c(start_year, start_month), frequency = 12)

  adf_p <- tryCatch(tseries::adf.test(na.omit(ts_ln), alternative = "stationary")$p.value,
                    error = function(e) NA_real_)
  kpss_p <- tryCatch(tseries::kpss.test(na.omit(ts_ln), null = "Level")$p.value,
                     error = function(e) NA_real_)
  seas_flag <- tryCatch(seastests::isSeasonal(na.omit(ts_ln), test = "wo"),
                        error = function(e) NA)

  tibble(subclase = sub_id, adf_p = adf_p, kpss_p = kpss_p, estacional = seas_flag)
}

res_tests <- panel_reg %>%
  distinct(subclase) %>%
  pull(subclase) %>%
  purrr::map_dfr(testear_subclase) %>%
  mutate(
    clasificacion = dplyr::case_when(
      !is.na(adf_p)  & adf_p < 0.05 & !is.na(kpss_p) & kpss_p > 0.1 ~ "Estacionaria (ADF rechaza RU, KPSS no rechaza)",
      !is.na(adf_p)  & adf_p >= 0.05 & !is.na(kpss_p) & kpss_p < 0.1 ~ "No estacionaria (posible RU)",
      TRUE ~ "Indefinida / revisar"
    )
  )

res_tests %>% count(clasificacion)
res_tests %>% count(estacional)
head(res_tests, 15)

```
