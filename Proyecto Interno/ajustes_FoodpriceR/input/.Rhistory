Median = round(median(value, na.rm = T),1),
Q1 = round(quantile(value, 0.25, na.rm = T),1),
Q3 = round(quantile(value, 0.75, na.rm = T),1))
output <- imputed.df
return(output)
}
#------------------------------------------------#
# Ingreso monetario por Primera Actividad (IMPA) #--------------------------------------------------------------------------------------------------------------------------
#------------------------------------------------#
# Definición del dominio
df_total$llave_impa <- (as.numeric(df_total$dom_terr)*100000) + (as.numeric(df_total$dom_edad)*10000) +
(as.numeric(df_total$dom_edu)*1000) + (as.numeric(df_total$dom_pos)*100) +
(as.numeric(df_total$sexo)*10) + (as.numeric(df_total$jefe))
# Imputación
impa_output <- comp_f(original = df_total, var = "impa",
dom = "llave_impa",
logical1 = "asalariado", logical2 = "independiente",
logical3 = "trab_familiares", logical4 = "asalariado",
y.bp = c(0, 7500), x.hist = c(0, 7500), y.hist = c(0, 0.0009),
xy.min.box = c(4000, 0.0006), xy.max.box = c(4500, 0.00065))
imputed_impa <- impa_output
colnames(imputed_impa)[which(colnames(imputed_impa) == "vi1")] = "IMPAES"
df_total <- merge(df_total, imputed_impa[c("id","IMPAES")], by = "id", all.x = T)
#------------------------------------------------#
# Ingreso monetario por Segunda Actividad (ISA)  #--------------------------------------------------------------------------------------------------------------------------
#------------------------------------------------#
# Definición del dominio
df_total$llave_isa <- (as.numeric(df_total$dom_terr)*1000) + (as.numeric(df_total$dom_edad)*100) + (as.numeric(df_total$edu)*10) + (as.numeric(df_total$dom_horas))
# Imputación
isa_output <- comp_f(original = df_total, var = "isa",
dom = "llave_isa",
logical1 = "asalariado", logical2 = "independiente",
logical3 = "trab_familiares", logical4 = "asalariado",
y.bp = c(0, 5000), x.hist = c(0, 5000), y.hist = c(0, 0.00003),
xy.min.box = c(2000, 0.000020), xy.max.box = c(4000, 0.000025))
imputed_isa <- isa_output
colnames(imputed_isa)[which(colnames(imputed_isa) == "vi1")] = "ISAES"
df_total <- merge(df_total, imputed_isa[c("id","ISAES")], by = "id", all.x = T)
#---------------------------------------#
# Ingreso en Especie (IE)               #--------------------------------------------------------------------------------------------------------------------------
#---------------------------------------#
# Definición del dominio
df_total$llave_ie <- (as.numeric(df_total$dom_terr)*100) + (as.numeric(df_total$dom_pos)*10) + (as.numeric(df_total$sexo))
# Imputación
ie_output <- comp_f(original = df_total, var = "ie",
dom = "llave_ie", y.bp = c(0, 100),
x.hist = c(0, 100), y.hist = c(0, 0.2), xy.min.box = c(50, 0.1),
xy.max.box = c(100, 0.15),
logical1 = "asalariado", logical2 = "asalariado",
logical3 = "asalariado", logical4 = "asalariado")
imputed_ie <- ie_output
colnames(imputed_ie)[which(colnames(imputed_ie) == "vi1")] = "IEES"
df_total <- merge(df_total, imputed_ie[c("id","IEES")], by = "id", all.x = T)
#--------------------------------#
# IMDI: valores para imputar     #------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#--------------------------------#
# Definición de actividad: Cesante-Aspirante, Desocupado, Estudiante, Hogar
df_total$llave_imdi <- (as.numeric(df_total$dom_terr)*100) + (as.numeric(df_total$dom_estrato)*10) + df_total$p6240
test <- df_total %>% dplyr::select(dom_terr, p6240, des_ina,
llave_imdi) %>% filter(des_ina == 1)
imdi_output <- comp_f(original = df_total, var = "imdi",
dom = "llave_imdi", y.bp = c(0, 5000),
x.hist = c(0, 5000), y.hist = c(0,0.002),
xy.min.box = c(2000, 0.00068),
xy.max.box = c(4000, 0.00078),
logical1 = "des_ina", logical2 = "des_ina",
logical3 = "des_ina", logical4 = "des_ina")
imputed_imdi <- imdi_output
colnames(imputed_imdi)[which(colnames(imputed_imdi) == "vi1")] = "IMDIES"
df_total <- merge(df_total, imputed_imdi[c("id","IMDIES")], by = "id", all.x = T)
#--------------------------------#
# IOF1: valores para imputar     #------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#--------------------------------#
df_total$llave_iof1 <- (as.numeric(df_total$dom_terr)*100) + (as.numeric(df_total$dom_pos)*10) + (as.numeric(df_total$p6240))
iof1_output <- comp_f(original = df_total,
dom = "llave_iof1",
var = "iof1", y.bp = c(0, 3),
x.hist = c(0, 3), y.hist = c(0,2.5), xy.min.box = c(1, 1.5),
xy.max.box = c(1, 2),
logical1 = "asalariado", logical2 = "independiente",
logical3 = "trab_familiares", logical4 = "des_ina")
imputed_iof1 <- iof1_output
colnames(imputed_iof1)[which(colnames(imputed_iof1) == "vi1")] = "IOF1ES"
df_total <- merge(df_total, imputed_iof1[c("id","IOF1ES")], by = "id", all.x = T)
#--------------------------------#
# IOF2: valores para imputar     #------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#--------------------------------#
df_total$llave_iof2 <- (as.numeric(df_total$dom_terr)*100) + (as.numeric(df_total$dom_pos)*10) + (as.numeric(df_total$p6240))
iof2_output <- comp_f(original = df_total,
dom = "llave_iof2",
var = "iof2", y.bp = c(0, 3),
x.hist = c(0, 3), y.hist = c(0,2.5), xy.min.box = c(1 , 1.5),
xy.max.box = c(1, 2),
logical1 = "asalariado", logical2 = "independiente",
logical3 = "trab_familiares", logical4 = "des_ina")
imputed_iof2 <- iof2_output
colnames(imputed_iof2)[which(colnames(imputed_iof2) == "vi1")] = "IOF2ES"
df_total <- merge(df_total, imputed_iof2[c("id","IOF2ES")], by = "id", all.x = T)
#--------------------------------#
# IOF3: valores para imputar     #------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#--------------------------------#
df_total$llave_iof3 <- (as.numeric(df_total$dom_terr)*100) + (as.numeric(df_total$dom_pos)*10) + (as.numeric(df_total$p6240))
iof3_output <- comp_f(original = df_total,
dom = "llave_iof3",
var = "iof3", y.bp = c(0, 500),
x.hist = c(0, 800), y.hist = c(0,0.02),
xy.min.box = c(450, 0.010),
xy.max.box = c(600, 0.015),
logical1 = "asalariado", logical2 = "independiente",
logical3 = "trab_familiares", logical4 = "des_ina")
imputed_iof3 <- iof3_output
colnames(imputed_iof3)[which(colnames(imputed_iof3) == "vi1")] = "IOF3ES"
df_total <- merge(df_total, imputed_iof3[c("id","IOF3ES")], by = "id", all.x = T)
#--------------------------------#
# IOF6: valores para imputar     #------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#--------------------------------#
df_total$llave_iof6 <- (as.numeric(df_total$dom_terr)*100) + (as.numeric(df_total$dom_pos)*10) + (as.numeric(df_total$p6240))
iof6_output <- comp_f(original = df_total,
dom = "llave_iof6",
var = "iof6", y.bp = c(0, 5000),
x.hist = c(0,5000), y.hist = c(0,0.005),
xy.min.box = c(2500, 0.003),
xy.max.box = c(3000, 0.004),
logical1 = "asalariado", logical2 = "independiente",
logical3 = "trab_familiares", logical4 = "des_ina")
imputed_iof6 <- iof6_output
colnames(imputed_iof6)[which(colnames(imputed_iof6) == "vi1")] = "IOF6ES"
df_total <- merge(df_total, imputed_iof6[c("id","IOF6ES")], by = "id", all.x = T)
#------------------------------------------------#
#------------------------------------------------#
#   Módulo 8.1: Comparación ingresos imputados   #
#------------------------------------------------#
#------------------------------------------------#
# Las pruebas sugieren que se omite la variable IOF6ES (se usa IOF6)
#---------------------------------#
#   FILTRANDO GEIH POR CIDUAD     #
#---------------------------------#
df_total <- df_total %>% filter(dominio == ciudad_asignada)
# Ingresos de asalariados
df_total$INGES_ASAL <- ifelse(df_total$asalariado == 1,
rowSums(df_total[c("IMPAES", "IEES",
"ISA", "IOF1", "IOF2",
"IOF3ES", "IOF6")],
na.rm = T)* NA ^ (rowSums(!is.na(df_total[c("IMPAES", "IEES",
"ISA", "IOF1", "IOF2",
"IOF3ES", "IOF6")])) == 0),
NA)
# Ingresos de independientes
df_total$INGES_IND <- ifelse(df_total$independiente == 1,
rowSums(df_total[c("IMPAES",
"ISA", "IOF1", "IOF2",
"IOF3ES", "IOF6")],
na.rm = T)* NA ^ (rowSums(!is.na(df_total[c("IMPAES",
"ISA", "IOF1", "IOF2",
"IOF3ES", "IOF6")])) == 0),
NA)
# Ingresos de trabajadores familiares
df_total$INGES_TF <- ifelse(df_total$trab_familiares == 1,
rowSums(df_total[c("ISA", "IOF1", "IOF2",
"IOF3ES", "IOF6")],
na.rm = T)* NA ^ (rowSums(!is.na(df_total[c("ISA", "IOF1", "IOF2",
"IOF3ES", "IOF6")])) == 0),
NA)
# Ingreso de desocupados e inactivos
df_total$INGES_NO <- ifelse(df_total$des_ina == 1,
rowSums(df_total[c("IMDI", "IOF1", "IOF2",
"IOF3ES", "IOF6")],
na.rm = T)* NA ^ (rowSums(!is.na(df_total[c("IMDI", "IOF1", "IOF2",
"IOF3ES", "IOF6")])) == 0),
NA)
# Cálculo del ingreso total
df_total$ingresos <- rowSums(df_total[c("INGES_ASAL",
"INGES_IND", "INGES_TF",
"INGES_NO")],
na.rm = T)* NA ^ (rowSums(!is.na(df_total[c("INGES_ASAL",
"INGES_IND", "INGES_TF",
"INGES_NO")])) == 0)
# Excluir los siguientes ingresos: parentesco con el jefe de hogar como
# empleados del servicio doméstico y sus parientes, trabajadores o pensionistas.
df_total$ingresos[df_total$ingresos %in% c(6,7,8,9)] = 0
cat("     Finalizado ✓ \n")
Sys.sleep(1);cat("Módulo 3: Cálculo ingresos de hogares y factores de expansión ")
dataset_x=df_total
# Cálculo del ingreso del hogar
# Definición de la unidad de gasto
# Variable dummy (1 = pertenece a la unidad de gasto, 0 otherwise)
dataset_x$ndummy <- ifelse(dataset_x$p6050 >= 10 & dataset_x$p6050 < 13, 0, 1)
########### Imputación de valores de arriendo
## Variable dummy para identificar si algún miembro en el hogar recibió vivienda en especie
dataset_x <- dataset_x %>% group_by(id_hogar) %>% mutate(vivi_esp = any(p6600 == 1, na.rm = T))
dataset_x$vivi_esp[is.nan(dataset_x$vivi_esp)] = FALSE
## Variable que define la propiedad de la vivienda (propia, propia pagando, etc.)
dataset_x <- dataset_x %>% group_by(id_hogar) %>% mutate(propiedad = unique(p5090))
## Creación de valor de arriendo para la imputación
if (any(dataset_x$p5100 %in% c(98, 99))) {
dataset_x$p5100 <- ifelse(dataset_x$p5100 %in% c(98, 99), 0, dataset_x$p5100)
}
if (any(dataset_x$p5130 %in% c(98, 99))) {
dataset_x$p5130 <- ifelse(dataset_x$p5130 %in% c(98, 99), 0, dataset_x$p5130)
}
## Tres criterios para el valor de arriendo imputado
dataset_x$arr_imp <- 0
dataset_x$arr_imp <- ifelse(dataset_x$propiedad == 1,
dataset_x$p5130,
ifelse(dataset_x$propiedad == 2,
dataset_x$p5130 - dataset_x$p5100,
ifelse(dataset_x$propiedad == 4 & !dataset_x$vivi_esp,
dataset_x$p5130,
0)))
## Criterios de control (no se considera ningún valor fuera del intervalo [10, 3000])
dataset_x$arr_imp[dataset_x$p5100 > 3000000 | dataset_x$p5130 > 3000000] <- 0
dataset_x$arr_imp[dataset_x$p5100 < 10000 | dataset_x$p5130 < 10000] <- 0
dataset_x$arr_imp[dataset_x$arr_imp < 0] <- 0
## Criterio de imputación sobre personas de desocupados e inactivos
dataset_x$ingresos <- ifelse(dataset_x$ingresos > quantile(dataset_x$ingresos, 0.99999, na.rm = T) &
dataset_x$des_ina == 1,
dataset_x$IMDIES, dataset_x$ingresos)
## Definición de variable al nivel de hogar
dataset_2 <- dataset_x %>% group_by(id_hogar) %>% filter(ndummy == 1) %>%
dplyr::summarise(
nug = sum(ndummy),                   # Número de personas en la unidad de gasto
ingtot_h = sum(ingresos, na.rm = T),   # Ingreso total del hogar
arriendo = unique(arr_imp),          # Valor de arriendo a imputar
fex_c18 = unique(fex_c18)
)
## Ingresos totales de los hogares con imputación de arriendo
dataset_2$ingresos <- rowSums(dataset_2[c("ingtot_h", "arriendo")], na.rm = T)
dataset_def= dataset_2
#-----------------------------#
# INICIO DEL MÓDULO 3 ORGINAL #
#-----------------------------#
# AQUÍ ESTÁ EL CAMBIO
# LA CLASIFICACIÓN POR DECILES USARÁ PESOS MUESTRALES (W)
dataset_def$per_capita <- dataset_def$ingresos / dataset_def$nug
deciles_cut <- wtd.quantile(dataset_def$per_capita,
weights = dataset_def$fex_c18,
probs = seq(0, 1, 0.1))
dataset_def$deciles <- cut(dataset_def$per_capita,
breaks = deciles_cut,
labels = paste0("Decil ", 1:10),
include.lowest = TRUE)
#-------------------------------------------------#
#               Tabla de resumen:                 #
#    ingreso (mean & max.) y gasto (mean & max.)  #
#-------------------------------------------------#
geih_ingresos = dataset_def
# Hallar el ingreso promedio por decil
dataset_def_deciles = dataset_def
deciles_grupos = c("Decil 1", "Decil 2",
"Decil 3", "Decil 4",
"Decil 5", "Decil 6",
"Decil 7", "Decil 8",
"Decil 9", "Decil 10")
cat("     Finalizado ✓ \n")
#----------------------------------------------------------------------------------#
#    Modulo 2: Proporcion del gasto en alimentación -ECV                           #
#----------------------------------------------------------------------------------#
if (!is.null(Share.n)) {
# Validar que share.n tenga exactamente 10 valores
if (length(Share.n) != 10) {
stop("El vector 'Share.n' debe tener exactamente 10 valores (uno por cada decil).")
}
# Crear el data.frame con las proporciones asignadas manualmente
new_share <- data.frame(
decil = c("Decil 1", "Decil 2", "Decil 3", "Decil 4",
"Decil 5", "Decil 6", "Decil 7", "Decil 8",
"Decil 9", "Decil 10"),
share = Share.n
)
# Crear un DataFrame con los niveles de los deciles
deciles_gasto <- data.frame(
deciles = levels(as.factor(new_share$decil))
)
# Hacer el merge con el DataFrame `new_share` para añadir las proporciones
deciles_gasto <- merge(deciles_gasto, new_share, by.x = "deciles", by.y = "decil", all.x = TRUE)
} else {
Sys.sleep(1);cat("Módulo  4: Cálculo del gasto en alimentación con base en la ECV")
descargar_y_cargar_datos_ecv <- function(Year) {
# Función para crear o reusar un entorno
crear_o_reusar_entorno <- function(nombre_entorno) {
if (!exists(nombre_entorno, envir = globalenv())) {
assign(nombre_entorno, new.env(parent = emptyenv()), envir = globalenv())
}
return(get(nombre_entorno, envir = globalenv()))
}
# Crear el nombre del entorno principal
data_ECV <- crear_o_reusar_entorno("data_ECV")
envr_name <- paste0("ECV_", 2022)
# Verificar si ya existen los datos en el entorno específico
if (exists(envr_name, envir = data_ECV)) {
cat(".  Los datos para", envr_name, "ya existen en el entorno. No se realizará la descarga nuevamente.\n")
return(invisible())
}
# Crear el entorno específico para el año
assign(envr_name, new.env(parent = emptyenv()), envir = data_ECV)
# Crear la URL base para la descarga
base_url <- "https://raw.githubusercontent.com/JuanArchis/Datos_GEIH_Foodprice2/main"
carpeta_anio <- paste0("ECV_", 2022)
# Lista de archivos esperados
archivos_esperados <- c("Caracteristicas y composicion del hogar.rda",
"Datos de la vivienda.rda",
"Gastos de los hogares (Gastos por Item).rda",
"Servicios del hogar.rda")
# Descargar y cargar cada archivo
for (archivo in archivos_esperados) {
url_archivo <- file.path(base_url, carpeta_anio, URLencode(archivo))
temp_file <- tempfile()
res <- try(GET(url_archivo, write_disk(temp_file, overwrite = TRUE)), silent = TRUE)
if (inherits(res, "try-error")) {
cat("No se pudo descargar el archivo:", archivo, "\n")
next
}
if (res$status_code == 200) {
load(temp_file)
nombre_variable <- sub("\\.rda$", "", basename(archivo))
nombre_variable <- gsub("[^[:alnum:]]", "_", nombre_variable)
# Asignar el contenido del archivo cargado a la variable en el entorno
assign(nombre_variable, as.data.frame(data), envir = get(envr_name, envir = data_ECV))
}
}
# Eliminar el archivo temporal
unlink(temp_file)
}
# Ejecutar la función para descargar y cargar datos
descargar_y_cargar_datos_ecv(2022)
#-------------------------------#
#     Depuración previa         #
#-------------------------------#
# Obtener nombres de los dataframes en el entorno específico ECV_Year si existe
envr_name <- paste0("ECV_", 2022)
gastos_hogares <- get(envr_name, envir = data_ECV)$Gastos_de_los_hogares__Gastos_por_Item_
hogares <- get(envr_name, envir = data_ECV)$Caracteristicas_y_composicion_del_hogar
vivienda <- get(envr_name, envir = data_ECV)$Datos_de_la_vivienda
servicios <- get(envr_name, envir = data_ECV)$Servicios_del_hogar
# Lista de ciudades y sus códigos correspondientes
ciudades_codigos <- c("63" = "ARMENIA", "8" = "BARRANQUILLA", "11" = "BOGOTA",
"68" = "BUCARAMANGA", "76" = "CALI", "13" = "CARTAGENA",
"54" = "CUCUTA", "18" = "FLORENCIA", "73" = "IBAGUE",
"17" = "MANIZALES", "5" = "MEDELLIN", "23" = "MONTERIA",
"41" = "NEIVA", "52" = "PASTO", "66" = "PEREIRA",
"19" = "POPAYAN", "27" = "QUIBDO", "44" = "RIOHACHA",
"47" = "SANTA MARTA", "70" = "SINCELEJO", "15" = "TUNJA",
"20" = "VALLEDUPAR", "50" = "VILLAVICENCIO")
# Función para obtener el código de ciudad a partir de la ciudad asignada
obtener_codigo_ciudad <- function(ciudad_asignada, ciudades_codigos) {
codigo <- names(ciudades_codigos)[match(ciudad_asignada, unname(ciudades_codigos))]
return(codigo)
}
codigo_ciudad=obtener_codigo_ciudad(ciudad_asignada,ciudades_codigos)
vivienda_ciudad <- vivienda %>% filter(P1_DEPARTAMENTO == as.numeric(codigo_ciudad))
gastos_hogares_ciudad = gastos_hogares %>% filter(DIRECTORIO %in% vivienda_ciudad$DIRECTORIO)
servicios_ciudad = servicios %>% filter(DIRECTORIO %in% vivienda_ciudad$DIRECTORIO)
# Selección de las variables de interés
vivienda_ciudad_1 = vivienda_ciudad[c("DIRECTORIO", "SECUENCIA_ENCUESTA", "SECUENCIA_P",
"ORDEN", "P1_DEPARTAMENTO", "CLASE", "FEX_C",
"CANT_HOG_COMPLETOS", "CANT_HOGARES_VIVIENDA")]
gastos_hogares_ciudad_1 = gastos_hogares_ciudad[c("DIRECTORIO", "SECUENCIA_ENCUESTA", "SECUENCIA_P",
"ORDEN", "FEX_C", "P3204", "P3204S1", "P3204S2")]
servicios_ciudad_1 = servicios_ciudad[c("DIRECTORIO", "SECUENCIA_ENCUESTA", "SECUENCIA_P", "ORDEN",
"I_HOGAR", "I_UGASTO", "PERCAPITA", "I_OU")]
###############################
## Cálculo del ingreso para  ##
##       cada hogar          ##
###############################
# construir id
servicios_ciudad_1$id = paste0(servicios_ciudad$DIRECTORIO,
"-",servicios_ciudad$ORDEN)
# ingresos hogares
hogar_ingresos = servicios_ciudad_1[c("id", "I_HOGAR")]
###########################################
## Cálculo del gasto total y  gasto      ##
##   en alimentación para cada hogar     ##
###########################################
# construir id
gastos_hogares_ciudad_1$id = paste0(gastos_hogares_ciudad_1$DIRECTORIO,
"-",gastos_hogares_ciudad_1$SECUENCIA_P)
# reemplazar NA por 0 en las variables de gasto
gastos_hogares_ciudad_1$P3204S1[is.na(gastos_hogares_ciudad_1$P3204S1)] = 0
gastos_hogares_ciudad_1$P3204S2[is.na(gastos_hogares_ciudad_1$P3204S2)] = 0
# construir base de datos de recepción
hogar_gastos = data.frame(levels(as.factor(gastos_hogares_ciudad_1$id)))
hogar_gastos$gasto_total = NA
hogar_gastos$gasto_alimentos = NA
colnames(hogar_gastos) = c("id", "gasto_total", "gasto_alimentos")
for (k in 1:nrow(hogar_gastos)) {
# bucle para gasto total
df_1 = data.frame()
df_1 = gastos_hogares_ciudad_1 %>% filter(id %in% hogar_gastos$id[k])
hogar_gastos$gasto_total[k] = sum(df_1$P3204S1) + sum(df_1$P3204S2)
#bucle para gasto en alimentos
df_2 = df_1 %>% filter(P3204 %in% c(1:26,32))
hogar_gastos$gasto_alimentos[k] = sum(df_2$P3204S1) + sum(df_2$P3204S2)
}
###################################
## Cálculo de las proporciones   ##
## (desde el ingreso y el gasto) ##
###################################
# recuperar el factor de expansión
hogar_gastos_dep = merge(hogar_gastos, gastos_hogares_ciudad_1[c("id","FEX_C")], by = "id")
hogar_gastos_dep = hogar_gastos_dep[!duplicated(hogar_gastos_dep),]
# eliminar valores nulos en alimentación
#hogar_gastos_dep = hogar_gastos_dep %>% filter(gasto_alimentos != 0)
# merge gastos-ingresos
gastos_ingresos = merge(hogar_gastos_dep, hogar_ingresos, by = "id")
# implementación del factor de expansión
gastos_ingresos_exp = as.data.frame(matrix(ncol = ncol(gastos_ingresos)))
colnames(gastos_ingresos_exp) = colnames(gastos_ingresos)
gastos_ingresos_exp <- gastos_ingresos %>%
dplyr::slice(rep(1:n(), times = gastos_ingresos$FEX_C)) %>%
na.omit()
# proporción del gasto
gastos_ingresos_exp$share_gasto = gastos_ingresos_exp$gasto_alimentos/gastos_ingresos_exp$gasto_total
# Nota: los resultados para la proporción del ingresos no tiene resultados realistas
############
## Ad hoc ##
############
# eliminar gastos e ingresos nulos
#gastos_ingresos_exp = gastos_ingresos_exp %>% filter(I_HOGAR != 0)
#gastos_ingresos_exp = gastos_ingresos_exp %>% filter(gasto_total != 0)
############################################
## Calcular deciles segun la clasificacion ##
##        derivada de la GEIH       ##
#############################################
# diferenciar los ingresos del hogar segun la clasificacion por
# deciles y quintiles de la GEIH
deciles = quantile(dataset_2$ingresos, probs = seq(0, 1, by = .1))
gastos_ingresos_exp = gastos_ingresos_exp %>% mutate(deciles = cut(I_HOGAR, deciles, c("Decil 1", "Decil 2",
"Decil 3", "Decil 4",
"Decil 5", "Decil 6",
"Decil 7", "Decil 8",
"Decil 9", "Decil 10")))
gastos_ingresos_exp = na.omit(gastos_ingresos_exp)
# calculo de proporciones medias del gasto en alimentacion (deciles)
mean_share = data.frame(c("Decil 1", "Decil 2",
"Decil 3", "Decil 4",
"Decil 5", "Decil 6",
"Decil 7", "Decil 8",
"Decil 9", "Decil 10"))
colnames(mean_share) = "decil"
mean_share$share = NA
for (i in 1:nrow(mean_share)) {
df = gastos_ingresos_exp %>% filter(deciles %in% mean_share$decil[i])
mean_share$share[i] = mean(df$share_gasto)
}
deciles_gasto = data.frame(
deciles = levels(as.factor(mean_share$decil)))
# Hacer el merge con el DataFrame `new_share` para añadir las proporciones
deciles_gasto <- merge(deciles_gasto, mean_share, by.x = "deciles", by.y = "decil", all.x = TRUE)
}
cat("     Finalizado ✓ \n")
Sys.sleep(1);cat("Módulo 5: Cálculos finales....")
dataset_def_deciles$id_aux = c(1:nrow(dataset_def_deciles))
dataset_def_deciles = merge(dataset_def_deciles, deciles_gasto, by = "deciles", all.x = TRUE)
dataset_def_deciles = dataset_def_deciles[order(dataset_def_deciles$id_aux),]
dataset_def_deciles = dataset_def_deciles[setdiff(colnames(dataset_def_deciles), "id_aux")]
# calcular ingreso dedicado a alimentacion
dataset_def_deciles$ingreso_alimentos = dataset_def_deciles$share*dataset_def_deciles$ingresos
dataset_def_deciles$ingreso_alimentos_per_capita = dataset_def_deciles$ingreso_alimentos/dataset_def_deciles$nug
#-------------------------------------------------#
#               Tabla de resumen:                 #
#    ingreso (mean & max.) y gasto (mean & max.)  #
#-------------------------------------------------#
dataset_def_deciles$per_capita_year = dataset_def_deciles$ingreso_alimentos_per_capita*12
dataset_def_deciles= dataset_def_deciles %>% dplyr::select(deciles,id_hogar,nug,fex_c18, ingresos,per_capita,share,ingreso_alimentos,
ingreso_alimentos_per_capita,per_capita_year)
# cambiando nombres
new_names <- c(
"deciles",
"household_id",
"ung",
"fex_c18",
"income",
"per_capita_income",
"share",
"food_exp",
"food_exp_per_capita",
"food_exp_per_capita_year"
)
# Cambiar los nombres de las columnas
names(dataset_def_deciles) <- new_names
Data_income_household=dataset_def_deciles
writexl::write_xlsx(Data_income_household, "data_enfoque2.xlsx")
data_enfoque1 = readxl::read_excel("data_enfoque1.xlsx")
setwd("C:\\Users\\Portatil\\Desktop\\Least-cost-diets-and-affordability\\Proyecto Interno\\ajustes_FoodpriceR\\input")
data_enfoque1 = readxl::read_excel("data_enfoque1.xlsx")
data_enfoque2 = readxl::read_excel("data_enfoque2.xlsx")
data_enfoque2 = readxl::read_excel("data_enfoque2.xlsx")
# writexl::write_xlsx(data_enfoque1, "data_enfoque1.xlsx")
writexl::write_xlsx(Data_income_household, "data_enfoque2.xlsx")
data_enfoque2 = readxl::read_excel("data_enfoque2.xlsx")
# Datos de costos (no cambian)
models = FoodpriceR::HCost(Month = 9, Year = 2022, City = "Cali",
Household = Household, EER_LL = EER_LL,
UL = UL, Serv = serv2, Diverse = diverse,
ERR = EER)
Model_CoCA = models$Model_CoCA
Model_CoNA = models$Model_CoNA
Model_CoRD = models$Model_CoRD
output_v1 = Afford(Hexpense = data_enfoque1,
Model_CoCA = Model_CoCA,
Model_CoNA = Model_CoNA,
Model_CoRD = Model_CoRD)
output_v1
output_v1$Poverty_outcome
output_v1$Poverty_outcome
output_v2 = Afford(Hexpense = data_enfoque2,
Model_CoCA = Model_CoCA,
Model_CoNA = Model_CoNA,
Model_CoRD = Model_CoRD)
output_v2$Poverty_outcome
output_v1$Poverty_outcome
View(output_v2$Poverty_outcome)
